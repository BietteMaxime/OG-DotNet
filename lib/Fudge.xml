<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Fudge</name>
    </assembly>
    <members>
        <member name="T:Fudge.Encodings.FudgeEncodedStreamReader">
            <summary>
            Provides a streaming way of reading binary streams containing messages encoded using Fudge encoding.
            </summary>
            <remarks>The Fudge Encoding Specification can be found at http://wiki.fudgemsg.org/display/FDG/Encoding+Specification</remarks>
        </member>
        <member name="T:Fudge.Encodings.FudgeStreamReaderBase">
            <summary>
            Base class to remove some of the boiler-plate in writing new <see cref="T:Fudge.IFudgeStreamReader"/>s.
            </summary>
        </member>
        <member name="T:Fudge.IFudgeStreamReader">
            <summary>
            IFudgeStreamReader is implemented by classes wishing to present data streams (e.g. Fudge binary encoding, XML, JSON) as Fudge messages.
            </summary>
            <remarks>
            <para>
            If you simply wish to extract a single message from a stream into a <see cref="T:Fudge.FudgeMsg"/> object, then use the
            <see cref="M:Fudge.Encodings.FudgeEncodingExtensions.ReadMsg(Fudge.IFudgeStreamReader)"/> extension method.
            </para>
            <para>
            The <see cref="N:Fudge.Encodings"/> namespace contains a variety of readers and writers for different file formats.
            </para>
            </remarks>
        </member>
        <member name="M:Fudge.IFudgeStreamReader.MoveNext">
            <summary>
            Moves to the next element within the stream.
            </summary>
            <returns>The type of element.</returns>
        </member>
        <member name="P:Fudge.IFudgeStreamReader.HasNext">
            <summary>
            Indicates whether there is remaining data in the stream.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeStreamReader.CurrentElement">
            <summary>
            Gets the type of the current stream element.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeStreamReader.FieldType">
            <summary>
            When the current element is a field, gives the type of the field.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeStreamReader.FieldOrdinal">
            <summary>
            When the current element is a field, gives the ordinal of the field, or <c>null</c> if none.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeStreamReader.FieldName">
            <summary>
            When the current element is a field, gives the name of the field, or <c>null</c> if none.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeStreamReader.FieldValue">
            <summary>
            When the current element is a field, gives the value of the field.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamReaderBase.#ctor">
            <summary>
            Cosntructs a new <c>FudgeStreamReaderBase</c>
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamReaderBase.MoveNext">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeStreamReaderBase.HasNext">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeStreamReaderBase.CurrentElement">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeStreamReaderBase.FieldType">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeStreamReaderBase.FieldOrdinal">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeStreamReaderBase.FieldName">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeStreamReaderBase.FieldValue">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.#ctor(Fudge.FudgeContext)">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeEncodedStreamReader"/> with a given <see cref="P:Fudge.Encodings.FudgeEncodedStreamReader.FudgeContext"/>.
            </summary>
            <param name="fudgeContext"><see cref="P:Fudge.Encodings.FudgeEncodedStreamReader.FudgeContext"/> to use for messages read from the stream.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.#ctor(Fudge.FudgeContext,System.IO.BinaryReader)">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeEncodedStreamReader"/> with a given <see cref="P:Fudge.Encodings.FudgeEncodedStreamReader.FudgeContext"/> reading from a specified <see cref="T:System.IO.BinaryReader"/>.
            </summary>
            <param name="fudgeContext"><see cref="P:Fudge.Encodings.FudgeEncodedStreamReader.FudgeContext"/> to use for messages read from the stream.</param>
            <param name="reader"><see cref="T:System.IO.BinaryReader"/> to read the binary data from.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.#ctor(Fudge.FudgeContext,System.IO.Stream)">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeEncodedStreamReader"/> with a given <see cref="P:Fudge.Encodings.FudgeEncodedStreamReader.FudgeContext"/> reading from a specified <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="fudgeContext"><see cref="P:Fudge.Encodings.FudgeEncodedStreamReader.FudgeContext"/> to use for messages read from the stream.</param>
            <param name="stream"><see cref="T:System.IO.Stream"/> to read the binary data from.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.Reset(System.IO.BinaryReader)">
            Reset the state of this parser for a new message.
            This method is primarily designed so that instances can be pooled to minimize
            object creation in performance sensitive code.
            
            @param dataInput
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.Reset(System.IO.Stream)">
            <summary>
            Resets the <see cref="T:Fudge.Encodings.FudgeEncodedStreamReader"/> to use a new input stream.
            </summary>
            <param name="inputStream"><see cref="T:System.IO.Stream"/> providing the binary data.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.MoveNext">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.IsEndOfSubMessage">
            <summary>
            Checks to see if we're at the end of a sub-message (or message), and if so pops the processing stack
            </summary>
            <returns>True if we were at the end of a sub-message.</returns>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.ConsumeFieldData">
            
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamReader.ConsumeMessageEnvelope">
            
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamReader.Reader">
            <summary>
            Gets the <see cref="T:System.IO.BinaryReader"/> used by this <see cref="T:Fudge.Encodings.FudgeEncodedStreamReader"/>.
            </summary>
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamReader.FudgeContext">
            <summary>
            Gets the <see cref="P:Fudge.Encodings.FudgeEncodedStreamReader.FudgeContext"/> used by this <see cref="T:Fudge.Encodings.FudgeEncodedStreamReader"/>.
            </summary>
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamReader.HasNext">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamReader.ProcessingDirectives">
            @return the processingDirectives
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamReader.SchemaVersion">
            @return the schemaVersion
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamReader.TaxonomyId">
            @return the taxonomy
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamReader.EnvelopeSize">
            @return the envelopeSize
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamReader.Taxonomy">
            @return the taxonomy
        </member>
        <member name="T:Fudge.Encodings.FudgeEncodedStreamWriter">
            <summary>
            <c>FudgeEncodedStreamWriter</c> writes Fudge messages using the Fudge Encoding Specification.
            </summary>
            <remarks>
            The full specification can be found at http://wiki.fudgemsg.org/display/FDG/Encoding+Specification
            </remarks>
        </member>
        <member name="T:Fudge.IFudgeStreamWriter">
            <summary>
            <c>IFudgeStreamWriter</c> is implemented by classes wishing to write data streams (e.g. Fudge binary encoding, XML, JSON) of Fudge messages.
            </summary>
            <remarks>
            The <see cref="N:Fudge.Encodings"/> namespace contains a variety of readers and writers for different file formats.
            </remarks>
        </member>
        <member name="M:Fudge.IFudgeStreamWriter.StartMessage">
            <summary>
            Starts a new top-level message.
            </summary>
        </member>
        <member name="M:Fudge.IFudgeStreamWriter.StartSubMessage(System.String,System.Nullable{System.Int32})">
            <summary>
            Starts a sub-message within the current message.
            </summary>
            <param name="name">Name of the field, or <c>null</c> if none.</param>
            <param name="ordinal">Ordinal of the field, or <c>null</c> if none.</param>
        </member>
        <member name="M:Fudge.IFudgeStreamWriter.WriteField(System.String,System.Nullable{System.Int32},Fudge.FudgeFieldType,System.Object)">
            <summary>
            Writes a simple field to the data stream.
            </summary>
            <param name="name">Name of the field, or <c>null</c> if none.</param>
            <param name="ordinal">Ordinal of the field, or <c>null</c> if none.</param>
            <param name="type">Type of the field, as a <see cref="T:Fudge.FudgeFieldType"/>, can be <c>null</c> in which case writer will determine type.</param>
            <param name="value">Value of the field.</param>
        </member>
        <member name="M:Fudge.IFudgeStreamWriter.WriteFields(System.Collections.Generic.IEnumerable{Fudge.IFudgeField})">
            <summary>
            Writes multiple fields to the data stream.
            </summary>
            <param name="fields">Fields to write.</param>
        </member>
        <member name="M:Fudge.IFudgeStreamWriter.EndSubMessage">
            <summary>
            Tells the writer that the current sub-message is finished.
            </summary>
        </member>
        <member name="M:Fudge.IFudgeStreamWriter.EndMessage">
            <summary>
            Tells the writer that we have finished with the whole top-level message.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.#ctor(Fudge.FudgeContext)">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeEncodedStreamWriter"/> using a given <see cref="T:Fudge.FudgeContext"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use to write messages.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.#ctor(Fudge.FudgeContext,System.IO.Stream)">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeEncodedStreamWriter"/> using a given <see cref="T:Fudge.FudgeContext"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use to write messages.</param>
            <param name="stream">Output stream to write to.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.Reset(System.IO.Stream)">
            <summary>
            Resets the <see cref="T:Fudge.Encodings.FudgeEncodedStreamWriter"/> to use a different <see cref="T:System.IO.Stream"/> for output.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.Reset(System.IO.BinaryWriter)">
            <summary>
            Resets the <see cref="T:Fudge.Encodings.FudgeEncodedStreamWriter"/> to use a different <see cref="T:System.IO.BinaryWriter"/> for output.
            </summary>
            <param name="writer"><see cref="T:System.IO.BinaryWriter"/> to use for output.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.StartMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.StartSubMessage(System.String,System.Nullable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.WriteField(System.String,System.Nullable{System.Int32},Fudge.FudgeFieldType,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.WriteFields(System.Collections.Generic.IEnumerable{Fudge.IFudgeField})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.EndSubMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodedStreamWriter.EndMessage">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeEncodedStreamWriter.TaxonomyId">
            <summary>
            Gets and sets the taxonomy ID used for messages.
            </summary>
        </member>
        <member name="T:Fudge.Encodings.FudgeEncodingExtensions">
            <summary>
            Extension methods for encoding and decoding using the <see cref="T:Fudge.IFudgeStreamReader"/> and <see cref="T:Fudge.IFudgeStreamWriter"/> classes.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodingExtensions.ReadMsg(Fudge.IFudgeStreamReader)">
            <summary>
            Convenience method for reading a <see cref="T:Fudge.FudgeMsg"/> from a <see cref="T:Fudge.IFudgeStreamReader"/>.
            </summary>
            <param name="reader">Reader providing the data for the message.</param>
            <returns>New message containing data from the reader.</returns>
        </member>
        <member name="M:Fudge.Encodings.FudgeEncodingExtensions.WriteMsg(Fudge.IFudgeStreamWriter,Fudge.FudgeMsg)">
            <summary>
            Convenience method for writing a <see cref="T:Fudge.FudgeMsg"/> to a <see cref="T:Fudge.IFudgeStreamWriter"/>.
            </summary>
            <param name="writer">Writer to write the data.</param>
            <param name="msg">Message to write.</param>
        </member>
        <member name="T:Fudge.Encodings.FudgeJSONStreamReader">
            <summary>
            Implementation of <see cref="T:Fudge.IFudgeStreamReader"/> that reads JSON messages
            </summary>
            <remarks>
            Parsing based on definition of syntax at http://www.json.org/ as of 2009-12-18.
            </remarks>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamReader.#ctor(Fudge.FudgeContext,System.IO.TextReader)">
            <summary>
            Constructs a <see cref="T:Fudge.Encodings.FudgeJSONStreamReader"/> on a given <see cref="T:System.IO.TextReader"/>.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="reader"><see cref="T:System.IO.TextReader"/> providing the data.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamReader.#ctor(Fudge.FudgeContext,System.String)">
            <summary>
            Constructs a <see cref="T:Fudge.Encodings.FudgeJSONStreamReader"/> using a <c>string</c> for the underlying data.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="text">Text containing JSON message.</param>
            <example>This example shows a simple JSON string being converted into a <see cref="T:Fudge.FudgeMsg"/> object:
            <code>
            string json = @"{""name"" : ""fred""}";
            FudgeMsg msg = new FudgeJSONStreamReader(json).ReadToMsg();
            </code>
            </example>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamReader.MoveNext">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeJSONStreamReader.HasNext">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Encodings.FudgeJSONStreamWriter">
            <summary>
            Allows Fudge messages to be output as JSON text.
            </summary>
            <seealso cref="T:Fudge.Encodings.FudgeJSONStreamReader"/>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamWriter.#ctor(Fudge.FudgeContext,System.IO.TextWriter)">
            <summary>
            Constructs a new instance.
            </summary>
            <param name="context">Context for the writer.</param>
            <param name="writer"><see cref="T:System.IO.TextWriter"/> to receive the output.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamWriter.StartMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamWriter.StartSubMessage(System.String,System.Nullable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamWriter.WriteField(System.String,System.Nullable{System.Int32},Fudge.FudgeFieldType,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamWriter.WriteFields(System.Collections.Generic.IEnumerable{Fudge.IFudgeField})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamWriter.EndSubMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeJSONStreamWriter.EndMessage">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Encodings.FudgeMsgStreamReader">
            <summary>
            <c>FudgeMsgStreamReader</c> allows a <see cref="T:Fudge.FudgeMsg"/> to be read as if it were a stream source of data.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamReader.#ctor(Fudge.FudgeContext,Fudge.FudgeMsg)">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeMsgStreamReader"/> using a given <see cref="T:Fudge.FudgeMsg"/> for data.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="msg"><see cref="T:Fudge.FudgeMsg"/> to provide as a stream.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamReader.#ctor(Fudge.FudgeContext,System.Collections.Generic.IEnumerable{Fudge.FudgeMsg})">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeMsgStreamReader"/> using a set of <see cref="T:Fudge.FudgeMsg"/>s for data.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="messages">Set <see cref="T:Fudge.FudgeMsg"/>s to provide as a stream.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamReader.MoveNext">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeMsgStreamReader.HasNext">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeMsgStreamReader.CurrentElement">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeMsgStreamReader.FieldType">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeMsgStreamReader.FieldOrdinal">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeMsgStreamReader.FieldName">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeMsgStreamReader.FieldValue">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Encodings.FudgeMsgStreamWriter">
            <summary>
            <c>FudgeMsgStreamWriter</c> allows the streaming API to be used to construct <see cref="T:Fudge.FudgeMsg"/>s.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.#ctor">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeMsgStreamWriter"/> which will use a default <see cref="T:Fudge.FudgeContext"/>.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.#ctor(Fudge.FudgeContext)">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeMsgStreamWriter"/> using a given <see cref="T:Fudge.FudgeContext"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use to construct messages.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.GetAllMessages">
            <summary>
            Gets the list of all <see cref="T:Fudge.FudgeMsg"/>s that have been written and removes them from the queue.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.PeekAllMessages">
            <summary>
            Gets the list of all <see cref="T:Fudge.FudgeMsg"/>s that have been written without removing them from the queue.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.DequeueMessage">
            <summary>
            Dequeues the first message that has been written.
            </summary>
            <returns>First message in queue, or null if none available</returns>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.StartMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.StartSubMessage(System.String,System.Nullable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.WriteField(System.String,System.Nullable{System.Int32},Fudge.FudgeFieldType,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.WriteFields(System.Collections.Generic.IEnumerable{Fudge.IFudgeField})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.EndSubMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeMsgStreamWriter.EndMessage">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Encodings.FudgeStreamMultiwriter">
            <summary>
            FudgeMultiWriter allows you to write to multiple writers simultaneously (e.g. from a <see cref="T:Fudge.Util.FudgeStreamPipe"/>.
            </summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamMultiwriter.#ctor(Fudge.IFudgeStreamWriter[])">
            <summary>
            Constructs a new <see cref="T:Fudge.Encodings.FudgeStreamMultiwriter"/>.
            </summary>
            <param name="writers">The set of <see cref="T:Fudge.IFudgeStreamWriter"/>s that this <see cref="T:Fudge.Encodings.FudgeStreamMultiwriter"/> will use.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamMultiwriter.StartMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamMultiwriter.StartSubMessage(System.String,System.Nullable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamMultiwriter.WriteField(System.String,System.Nullable{System.Int32},Fudge.FudgeFieldType,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamMultiwriter.WriteFields(System.Collections.Generic.IEnumerable{Fudge.IFudgeField})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamMultiwriter.EndSubMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeStreamMultiwriter.EndMessage">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Encodings.FudgeParseException">
            <summary>
            FudgeParseException is thrown when bad data is encountered by an <see cref="T:Fudge.IFudgeStreamReader"/>.
            </summary>
        </member>
        <member name="T:Fudge.FudgeRuntimeException">
            <summary>
            A Fudge-specific subclass of <see cref="T:System.Exception"/> for all exceptions
            generated by Fudge. 
            </summary>
        </member>
        <member name="M:Fudge.FudgeRuntimeException.#ctor(System.String)">
            <summary>
            Creates a new exception object.
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:Fudge.FudgeRuntimeException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new exception object in response to an underlying error.
            </summary>
            <param name="message">error message</param>
            <param name="cause">underlying error</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeParseException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Fudge.Encodings.FudgeXmlStreamReader">
            <summary>
            <c>FudgeXmlStreamReader</c> provides a way of reading XML data as a Fudge stream.
            </summary>
            <remarks>
            There is not a 1-1 mapping between XML structure and Fudge message structure.  In particular, attributes are treated in the same way as
            child elements (i.e. as fields of the Fudge message), so a message that is read from a <see cref="T:Fudge.Encodings.FudgeXmlStreamReader"/> and written
            to a <see cref="T:Fudge.Encodings.FudgeXmlStreamWriter"/> may not come out identical.
            </remarks>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamReader.#ctor(Fudge.FudgeContext,System.Xml.XmlReader)">
            <summary>
            Constructs a new <c>FudgeXmlStreamReader</c> using a given <see cref="T:System.Xml.XmlReader"/> as the source of the XML data.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="reader"><see cref="T:System.Xml.XmlReader"/> providing the XML data</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamReader.#ctor(Fudge.FudgeContext,System.IO.Stream)">
            <summary>
            Constructs a new <c>FudgeXmlStreamReader</c> with the XML data coming from a <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="stream"></param>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamReader.#ctor(Fudge.FudgeContext,System.String)">
            <summary>
            Constructs a new <c>FudgeXmlStreamReader</c> with the XML data coming from a string.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="xml"></param>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamReader.MoveNext">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeXmlStreamReader.HasNext">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Encodings.FudgeXmlStreamWriter">
            <summary>
            <c>FudgeXmlStreamWriter</c> allows Fudge messages to be output as XML.
            </summary>
        </member>
        <member name="F:Fudge.Encodings.FudgeXmlStreamWriter.AutoFlushOnMessageEndProperty">
            <summary>Set this property in the <see cref="T:Fudge.FudgeContext"/> to give the default behaviour for flushing messages when they are complete.</summary>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamWriter.#ctor(Fudge.FudgeContext,System.Xml.XmlWriter,System.String)">
            <summary>
            Constructs a new <c>FudgeXmlStreamWriter</c>, outputting to a given <see cref="T:System.Xml.XmlWriter"/>.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="writer"><see cref="T:System.Xml.XmlWriter"/> to use to output XML.</param>
            <param name="outerElementName">The name of the XML element used for outermost messages.</param>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamWriter.#ctor(Fudge.FudgeContext,System.IO.Stream,System.String)">
            <summary>
            Constructs a new <c>FudgeXmlStreamWriter</c>, outputting to a given <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="context">Context to control behaviours.</param>
            <param name="stream"><see cref="T:System.IO.Stream"/> to use to output XML.</param>
            <param name="outerElementName">The name of the XML element used for outermost messages.</param>
            <remarks>
            if you want greater control over the way the XML is written, use the constructor that takes an <see cref="T:System.Xml.XmlWriter"/>.
            </remarks>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamWriter.StartMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamWriter.StartSubMessage(System.String,System.Nullable{System.Int32})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamWriter.WriteField(System.String,System.Nullable{System.Int32},Fudge.FudgeFieldType,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamWriter.WriteFields(System.Collections.Generic.IEnumerable{Fudge.IFudgeField})">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamWriter.EndSubMessage">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Encodings.FudgeXmlStreamWriter.EndMessage">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Encodings.FudgeXmlStreamWriter.AutoFlushOnMessageEnd">
            <summary>
            If true, the <c>FudgeXmlStreamWriter</c> will flush the <see cref="T:System.Xml.XmlWriter"/> whenever a top-level message is completed.
            </summary>
        </member>
        <member name="T:Fudge.Encodings.NamespaceDoc">
            <summary>
            Classes to implement encoding and decoding Fudge message streams to various formats.
            </summary>
            <remarks>
            <para>
            Fudge supports a generic notion of streams of hierarchical messages.  As well as the
            <a href="http://www.fudgemsg.org/display/FDG/Encoding+Specification">Fudge binary encoding</a>,
            it supports a number of other commonly-used formats.
            </para>
            <para>
            A particular encoding is implemented by providing two classes - one to read the stream
            and the other to write the stream, implementing <see cref="T:Fudge.IFudgeStreamReader"/> and
            <see cref="T:Fudge.IFudgeStreamWriter"/> respectively.  The currently supported formats are:
            <list type="table">
            <listheader>
            <term>Format</term>
            <description>Supporting classes</description>
            </listheader>
            <item><term>Fudge binary encoding</term><description><see cref="T:Fudge.Encodings.FudgeEncodedStreamReader"/>, <see cref="T:Fudge.Encodings.FudgeEncodedStreamWriter"/></description></item>
            <item><term>XML</term><description><see cref="T:Fudge.Encodings.FudgeXmlStreamReader"/>, <see cref="T:Fudge.Encodings.FudgeXmlStreamWriter"/></description></item>
            <item><term><see cref="T:Fudge.FudgeMsg"/> objects</term><description><see cref="T:Fudge.Encodings.FudgeMsgStreamReader"/>, <see cref="T:Fudge.Encodings.FudgeMsgStreamWriter"/></description></item>
            <item><term>JSON</term><description><see cref="T:Fudge.Encodings.FudgeJSONStreamReader"/></description></item>
            </list>
            </para>
            <para>The <see cref="T:Fudge.Encodings.FudgeStreamMultiwriter"/> class also allows you to write to multiple encodings simultaneously.</para>
            </remarks>
        </member>
        <member name="T:Fudge.Field">
            <summary>
            <c>Field</c> is a convenience class to allow functional construction of messages.
            </summary>
            <remarks>
            <c>Field</c> merely holds the data until they are added to a <see cref="T:Fudge.FudgeMsg"/>, and
            in particular, the field type is not determined by <c>Field</c>.
            </remarks>
            <example>
            The following example shows constructing a message containing two sub-messages:
            <code>
            var inputMsg = new FudgeMsg(   
                                new Field("sub1",
                                    new Field("bibble", "fibble"),
                                    new Field(827, "Blibble")),
                                new Field("sub2", 
                                    new Field("bibble9", 9837438),
                                    new Field(828, 82.77f)));
            </code>
            </example>
        </member>
        <member name="T:Fudge.IFudgeField">
            <summary>
            A read-only representation of a field which is contained in a fudge
            message, or a stream of fudge encoded data.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeField.Type">
            <summary>
            Gets the type of the field.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeField.Value">
            <summary>
            Gets the .NET value of the field.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeField.Ordinal">
            <summary>
            Gets the ordinal index of the field, or null if none is specified.
            </summary>
        </member>
        <member name="P:Fudge.IFudgeField.Name">
            <summary>
            Gets the descriptive name of the field, or null if none is specified.
            </summary>
        </member>
        <member name="M:Fudge.Field.#ctor(System.String,System.Object)">
            <summary>
            Constructs a field with a name and value.
            </summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fudge.Field.#ctor(System.Int32,System.Object)">
            <summary>
            Constructs a field with an ordinal and value.
            </summary>
            <param name="ordinal"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fudge.Field.#ctor(System.String,Fudge.IFudgeField[])">
            <summary>
            Constructs a named field that contains a sub-message of other fields.
            </summary>
            <param name="name"></param>
            <param name="subFields"></param>
            <example>
            The following example shows a hierarchical message being created using <see cref="T:Fudge.Field"/>.
            <code>
            FudgeMsg inputMsg = context.NewMessage(
                       new Field("sub1",
                           new Field("bibble", "fibble"),
                           new Field(827, "Blibble")),
                       new Field("sub2",
                           new Field("bibble9", 9837438),
                           new Field(828, 82.77f)));
            
            </code>
            </example>
        </member>
        <member name="M:Fudge.Field.#ctor(System.String,System.Nullable{System.Int32},System.Object)">
            <summary>
            Constructs a field with both a name and an ordinal plus value.
            </summary>
            <param name="name"></param>
            <param name="ordinal"></param>
            <param name="value"></param>
        </member>
        <member name="P:Fudge.Field.Type">
            <summary>
            Returns <c>null</c>.
            </summary>
            <remarks>The field type is not calculated until the field is added to a <see cref="T:Fudge.FudgeMsg"/>.</remarks>
        </member>
        <member name="P:Fudge.Field.Value">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Field.Ordinal">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Field.Name">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Field.FieldContainer">
            <summary>
            Implementation of <see cref="T:Fudge.IFudgeFieldContainer"/> purely to hold sub-fields
            </summary>
        </member>
        <member name="T:Fudge.IFudgeFieldContainer">
            <summary>
             An interface defining any arbitrary container for fields that can
             be described by the Fudge specification.
            </summary>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetNumFields">
            <summary>
            Returns the number of fields currently in this message.
            </summary>
            <returns>number of fields</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetAllFields">
            <summary>
            Return an unmodifiable list of all the fields in this message, in the index
            order for those fields.
            </summary>
            <returns>a list of all fields in this message</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetAllFieldNames">
            <summary>
            Returns a list of all field names currently in this message. Any fields which are referenced by ordinal only are ignored.
            </summary>
            <returns>a list of all field names in this message</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetByIndex(System.Int32)">
            <summary>
            Returns a field at a specific index into the message. This index is the physical position at which the field was added to the message, it is not
            the same as the ordinal index of a field. Returns null if the index is is too great and the message doesn't contain that many fields.
            </summary>
            <param name="index">physical index of the field</param>
            <returns>the field</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetAllByOrdinal(System.Int32)">
            <summary>
            Returns a list of all fields with the given ordinal index. Returns the empty list if there are no matching fields.
            </summary>
            <param name="ordinal">ordinal index</param>
            <returns>a list of matching fields</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetByOrdinal(System.Int32)">
            <summary>
            Returns a field with the given ordinal index, or null if that index does not exist. In the case of multiple fields with the same ordinal index,
            the first (i.e. the lowest physical index) is returned.
            </summary>
            <param name="ordinal">ordinal index</param>
            <returns>the field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetAllByName(System.String)">
            <summary>
            Returns a list of all fields with the given field name. Returns the empty list if there are no matching fields.
            </summary>
            <param name="name">field name</param>
            <returns>a list of matching fields</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetByName(System.String)">
            <summary>
            Returns a field with the given name, or null if that name does not exist. In the case of multiple fields with the same field name, the first (i.e.
            the lowest physical index) is returned.
            </summary>
            <param name="name">field name</param>
            <returns>the field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue(System.String)">
            <summary>
            Returns the value of the field that would be returned by <c>GetByName</c>, or null if there is no matching field.
            </summary>
            <param name="name">field name</param>
            <returns>value of matching field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue``1(System.String)">
            <summary>
            Returns the typed value of the field that would be returned by <c>GetByName</c>, or null if there is no matching field.
            </summary>
            <typeparam name="T">underlying .NET type of the field</typeparam>
            <param name="name">field name</param>
            <returns>value of matching field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue(System.String,System.Type)">
            <summary>
            Returns the value of the field that would be returned by <c>GetByName</c>, or null if there is no matching field. The return type is converted to
            the requested type.
            </summary>
            <param name="name">field name</param>
            <param name="type">requested .NET type of the returned value</param>
            <returns>value of matching field, converted to the requested type, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue(System.Int32)">
            <summary>
            Returns the value of the field that would be returned by <c>GetByOrdinal</c>, or null if there is no matching field.
            </summary>
            <param name="ordinal">ordinal index</param>
            <returns>field value, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue``1(System.Int32)">
            <summary>
            Returns the typed value of the field that would be returned by <c>GetByOrdinal</c>, or null if there is no matching field.
            </summary>
            <typeparam name="T">underlying .NET type of the field</typeparam>
            <param name="ordinal">ordinal index</param>
            <returns>value of matching field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue(System.Int32,System.Type)">
            <summary>
            Returns the value of the field that would be returned by <c>GetByOrdinal</c>, or null if there is no matching field.
            The return type is converted to the requested type.
            </summary>
            <param name="ordinal">ordinal index</param>
            <param name="type">requested .NET type of the returned value</param>
            <returns>value of matching field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue(System.String,System.Nullable{System.Int32})">
            <summary>
            Returns the value of the first field (i.e. lowest physical index) with either a matching name or ordinal index.
            </summary>
            <param name="name">field name, or null to only search by ordinal index</param>
            <param name="ordinal">ordinal index, or null to only search by name</param>
            <returns>value of matching field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue``1(System.String,System.Nullable{System.Int32})">
            <summary>
            Returns the typed value of the first field (i.e. lowest physical index) with either a matching name or ordinal index.
            </summary>
            <typeparam name="T">underlying .NET type of the field</typeparam>
            <param name="name">field name, or null to only search by ordinal index</param>
            <param name="ordinal">ordinal index, or null to only search by name</param>
            <returns>value of matching field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetValue(System.String,System.Nullable{System.Int32},System.Type)">
            <summary>
            Returns the value of the first field (i.e. lowest physical index) with either a matching name or ordinal index. The return type
            is converted to the requested type.
            </summary>
            <param name="name">field name, or null to only search by ordinal index</param>
            <param name="ordinal">ordinal index, or null to only search by name</param>
            <param name="type">requested .NET type of the returned value</param>
            <returns>value of matching field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetDouble(System.String)">
            <summary>Returns the value of a field as a double, or null if the field does not exist.
            In the case of multiple fields with the same field name, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>double</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>double</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetDouble(System.Int32)">
            <summary>Returns the value of a field as a double, or null if the field does not exist.
            In the case of multiple fields with the same ordinal index, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>double</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>double</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetFloat(System.String)">
            <summary>Returns the value of a field as a float, or null if the field does not exist.
            In the case of multiple fields with the same field name, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>float</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>float</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetFloat(System.Int32)">
            <summary>Returns the value of a field as a float, or null if the field does not exist.
            In the case of multiple fields with the same ordinal index, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>float</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>float</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetLong(System.String)">
            <summary>Returns the value of a field as a long, or null if the field does not exist.
            In the case of multiple fields with the same field name, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>long</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>long</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetLong(System.Int32)">
            <summary>Returns the value of a field as a long, or null if the field does not exist.
            In the case of multiple fields with the same ordinal index, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>long</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>long</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetInt(System.String)">
            <summary>Returns the value of a field as a int, or null if the field does not exist.
            In the case of multiple fields with the same field name, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to an <c>int</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within an <c>int</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetInt(System.Int32)">
            <summary>Returns the value of a field as a int, or null if the field does not exist.
            In the case of multiple fields with the same ordinal index, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to an <c>int</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within an <c>int</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetShort(System.String)">
            <summary>Returns the value of a field as a short, or null if the field does not exist.
            In the case of multiple fields with the same field name, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>short</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>short</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetShort(System.Int32)">
            <summary>Returns the value of a field as a short, or null if the field does not exist.
            In the case of multiple fields with the same ordinal index, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>short</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>short</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetSByte(System.String)">
            <summary>Returns the value of a field as a byte, or null if the field does not exist.
            In the case of multiple fields with the same field name, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>byte</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>byte</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetSByte(System.Int32)">
            <summary>Returns the value of a field as a byte, or null if the field does not exist.
            In the case of multiple fields with the same ordinal index, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>byte</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>byte</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetBoolean(System.String)">
            <summary>Returns the value of a field as a boolean, or null if the field does not exist.
            In the case of multiple fields with the same field name, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>bool</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>bool</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetBoolean(System.Int32)">
            <summary>Returns the value of a field as a boolean, or null if the field does not exist.
            In the case of multiple fields with the same ordinal index, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>bool</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>bool</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetString(System.String)">
            <summary>Returns the value of a field as a string, or null if the field does not exist.
            In the case of multiple fields with the same field name, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>string</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>string</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetString(System.Int32)">
            <summary>Returns the value of a field as a string, or null if the field does not exist.
            In the case of multiple fields with the same ordinal index, the first (i.e. the lowest physical index) is returned.</summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
            <exception cref="T:System.InvalidCastException">Field type could not be converted to a <c>string</c></exception>
            <exception cref="T:System.OverflowException">Field value could not fit within a <c>string</c></exception>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetMessage(System.String)">
            <summary>
            Returns a submessage with the given field name. In the case of multiple submessage fields with the same name,
            the first (i.e. lowest physical index) is returned. Fields with a matching name but are not submessages are ignored.
            </summary>
            <param name="fieldName">field name</param>
            <returns>value, or <c>null</c> if field not found.</returns>
        </member>
        <member name="M:Fudge.IFudgeFieldContainer.GetMessage(System.Int32)">
            <summary>
            Returns a submessage with the given ordinal index. In the case of multiple submessage fields with the same ordinal index,
            the first (i.e. lowest physical index) is returned. Fields with a matching ordinal index but are not submessages are ignored.
            </summary>
            <param name="ordinal">ordinal index</param>
            <returns>value, or <c>null</c> if field not found.</returns>
        </member>
        <member name="T:Fudge.FudgeContext">
            <summary>
            The primary entry-point for code to interact with the rest of the fudge system.
            For performance reasons, there are many options that are passed around as parameters
            inside static methods for encoding and decoding, and many lightweight objects that
            ideally don't know of their configuration context.
            However, in a large application, it is often desirable to collect all configuration
            parameters in one location and inject options into it.
            <p/>
            <c>FudgeContext</c> allows application developers to have a single location
            to inject dependent parameters and instances, and make them available through
            simple method invocations. in addition, because it wraps all checked exceptions
            into instances of <see cref="T:Fudge.FudgeRuntimeException"/>, it is the ideal way to use
            the fudge encoding system from within spring applications.
            <p/>
            While most applications will have a single instance of <c>FudgeContext</c>,
            some applications will have one instance per unit of encoding/decoding parameters.
            for example, if an application is consuming data from two messaging feeds, each
            of which reuses the same taxonomy id to represent a different
            <see cref="T:Fudge.Taxon.IFudgeTaxonomy"/>, it would configure two different instances of
            <c>FudgeContext</c>, one per feed.  
            </summary>
        </member>
        <member name="M:Fudge.FudgeContext.#ctor">
            <summary>
            Constructs a new <see cref="T:Fudge.FudgeContext"/>.
            </summary>
        </member>
        <member name="M:Fudge.FudgeContext.NewMessage">
            <summary>
            Creates a new, empty <c>FudgeMsg</c> object.
            </summary>
            <returns>the <c>FudgeMsg</c> created</returns>
        </member>
        <member name="M:Fudge.FudgeContext.NewMessage(Fudge.IFudgeField[])">
            <summary>
            Creates a new <see cref="T:Fudge.FudgeMsg"/> containing the given fields.
            </summary>
            <param name="fields">Fields to add to message.</param>
            <returns>The new <see cref="T:Fudge.FudgeMsg"/>.</returns>
        </member>
        <member name="M:Fudge.FudgeContext.Serialize(Fudge.FudgeMsg,System.IO.Stream)">
            <summary>
            Encodes a <c>FudgeMsg</c> object to a <c>Stream</c> without any taxonomy reference.
            </summary>
            <param name="msg">The message to serialise</param>
            <param name="s">The stream to serialise to</param>
        </member>
        <member name="M:Fudge.FudgeContext.Serialize(Fudge.FudgeMsg,System.IO.BinaryWriter)">
            <summary>
            Encodes a <c>FudgeMsg</c> object to a <see cref="T:System.IO.BinaryWriter"/> without any taxonomy reference.
            </summary>
            <param name="msg">The message to serialise</param>
            <param name="bw">The <see cref="T:System.IO.BinaryWriter"/> to serialise to</param>
        </member>
        <member name="M:Fudge.FudgeContext.Serialize(Fudge.FudgeMsg,System.Nullable{System.Int16},System.IO.Stream)">
            <summary>
            Encodes a <c>FudgeMsg</c> object to a <c>Stream</c> with an optional taxonomy reference.
            If a taxonomy is supplied it may be used to optimize the output by writing ordinals instead
            of field names.
            </summary>
            <param name="msg">the <c>FudgeMessage</c> to write</param>
            <param name="taxonomyId">the identifier of the taxonomy to use. Specify <c>null</c> for no taxonomy</param>
            <param name="s">the <c>Stream</c> to write to</param>
        </member>
        <member name="M:Fudge.FudgeContext.Serialize(Fudge.FudgeMsg,System.Nullable{System.Int16},System.IO.BinaryWriter)">
            <summary>
            Encodes a <c>FudgeMsg</c> object to a <c>Stream</c> with an optional taxonomy reference.
            If a taxonomy is supplied it may be used to optimize the output by writing ordinals instead
            of field names.
            </summary>
            <param name="msg">the <c>FudgeMessage</c> to write</param>
            <param name="taxonomyId">the identifier of the taxonomy to use. Specify <c>null</c> for no taxonomy</param>
            <param name="bw">The <see cref="T:System.IO.BinaryWriter"/> to serialise to</param>
        </member>
        <member name="M:Fudge.FudgeContext.ToByteArray(Fudge.FudgeMsg)">
            <summary>
            Returns the Fudge encoded form of a <c>FudgeMsg</c> as a <c>byte</c> array without a taxonomy reference.
            </summary>
            <param name="msg">the <c>FudgeMsg</c> to encode</param>
            <returns>an array containing the encoded message</returns>
        </member>
        <member name="M:Fudge.FudgeContext.Deserialize(System.IO.Stream)">
            <summary>
            Decodes a <c>FudgeMsg</c> from a <c>Stream</c>.
            </summary>
            <param name="s">the <c>Stream</c> to read encoded data from</param>
            <returns>the next <c>FudgeMsgEnvelope</c> encoded on the stream</returns>
        </member>
        <member name="M:Fudge.FudgeContext.Deserialize(System.Byte[])">
            <summary>
            Decodes a <c>FudgeMsg</c> from a <c>byte</c> array. If the array is larger than the Fudge envelope, any additional data is ignored.
            </summary>
            <param name="bytes">an array containing the envelope encoded <c>FudgeMsg</c></param>
            <returns>the decoded <c>FudgeMsgEnvelope</c></returns>
        </member>
        <member name="M:Fudge.FudgeContext.GetProperty(Fudge.FudgeContextProperty)">
            <summary>
            Gets the value of a specific property from this context, or null if not set.
            </summary>
            <param name="prop">Property to retrieve.</param>
            <returns>Property value or null if not set.</returns>
        </member>
        <member name="M:Fudge.FudgeContext.GetProperty(Fudge.FudgeContextProperty,System.Object)">
            <summary>
            Gets the value of a specific property from this context, or returns <c>defaultValue</c> if not set.
            </summary>
            <param name="prop">Property to retrieve.</param>
            <param name="defaultValue">Value to return if property not set.</param>
            <returns>Property value or <c>defaultValue</c> if not set.</returns>
        </member>
        <member name="M:Fudge.FudgeContext.SetProperty(Fudge.FudgeContextProperty,System.Object)">
            <summary>
            Sets the value of a specific property in the context.
            </summary>
            <param name="prop">Property to set.</param>
            <param name="value">Value for the property.</param>
            <remarks>
            Context properties are used to control the behaviour of encoding and decoding.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the value is rejected by the <see cref="T:Fudge.FudgeContextProperty"/> as invalid.</exception>
        </member>
        <member name="P:Fudge.FudgeContext.TaxonomyResolver">
            <summary>
            Gets or sets the <c>ITaxonomyResolver</c> for use within this context when encoding or decoding messages.
            </summary>
        </member>
        <member name="P:Fudge.FudgeContext.TypeDictionary">
            <summary>
            Gets or sets the <c>FudgeTypeDictionary</c> for use within this context when encoding or decoding messages.
            </summary>
        </member>
        <member name="P:Fudge.FudgeContext.TypeHandler">
            <summary>
            Gets the <see cref="T:Fudge.FudgeContext.FudgeTypeHandler"/> for this context.
            </summary>
        </member>
        <member name="T:Fudge.FudgeContext.FudgeTypeHandler">
            <summary>
            <c>FudgeTypeHandler</c> provides methods to handle type-related functions.
            </summary>
        </member>
        <member name="M:Fudge.FudgeContext.FudgeTypeHandler.#ctor(Fudge.FudgeTypeDictionary)">
            <summary>
            Constructor
            </summary>
            <param name="typeDictionary"></param>
        </member>
        <member name="M:Fudge.FudgeContext.FudgeTypeHandler.ConvertType(System.Object,System.Type)">
            <summary>
            Converts the supplied value to a base type using the corresponding FudgeFieldType definition. The supplied .NET type
            is resolved to a registered FudgeFieldType. The <c>ConvertValueFrom</c> method on the registered type is then used
            to convert the value.
            </summary>
            <param name="value">value to convert</param>
            <param name="type">.NET target type</param>
            <returns>the converted value</returns>
        </member>
        <member name="M:Fudge.FudgeContext.FudgeTypeHandler.DetermineTypeFromValue(System.Object)">
            <summary>
            Determines the <c>FudgeFieldType</c> of a C# value.
            </summary>
            <param name="value">value whose type is to be determined</param>
            <returns>the appropriate <c>FudgeFieldType</c> instance</returns>
        </member>
        <member name="T:Fudge.FudgeContextProperty">
            <summary>
            Identifies a property within a <see cref="T:Fudge.FudgeContext"/>.
            </summary>
            <remarks>
            <para>Properties are ussed to control encoding and decoding behaviour.  They are set and retrieved
            through the <see cref="M:Fudge.FudgeContext.SetProperty(Fudge.FudgeContextProperty,System.Object)"/> and <see cref="M:Fudge.FudgeContext.GetProperty(Fudge.FudgeContextProperty)"/>
            methods of <see cref="T:Fudge.FudgeContext"/>.</para>
            <para>The validation function can be specified as a parameter to the constructor, or by deriving
            from this class and overriding <see cref="M:Fudge.FudgeContextProperty.IsValidValue(System.Object)"/>.</para>
            </remarks>
        </member>
        <member name="M:Fudge.FudgeContextProperty.#ctor(System.String)">
            <summary>
            Construct a property with a given name and no validation of values.
            </summary>
            <param name="name">Name of the property (used for exceptions).</param>
        </member>
        <member name="M:Fudge.FudgeContextProperty.#ctor(System.String,System.Func{System.Object,System.Boolean})">
            <summary>
            Cosntruct a property with a given name and validation function.
            </summary>
            <param name="name">Name of the property (used for exceptions).</param>
            <param name="validator">Delegate to use to validate values.</param>
        </member>
        <member name="M:Fudge.FudgeContextProperty.#ctor(System.String,System.Type)">
            <summary>
            Construct a property with a given name that only requires values to be of a specific type (or specialisation thereof).
            </summary>
            <param name="name">Name of the property (used for exceptions).</param>
            <param name="type">Type that values must be.</param>
        </member>
        <member name="M:Fudge.FudgeContextProperty.IsValidValue(System.Object)">
            <summary>
            Tests the value to ensure that it is valid for this property.
            </summary>
            <remarks>
            By default, this will call the validator delegate (if any) given to the constructor,
            but may alternatively be overridden in a derived class instead.
            </remarks>
            <param name="value">Value to test.</param>
            <returns><c>true</c> if the value is valid.</returns>
        </member>
        <member name="P:Fudge.FudgeContextProperty.Name">
            <summary>
            Gets the name of the property.
            </summary>
        </member>
        <member name="T:Fudge.FudgeEncodingObject">
            <summary>
            The base type for all objects which can be encoded using Fudge. 
            </summary>
        </member>
        <member name="M:Fudge.FudgeEncodingObject.GetSize(Fudge.Taxon.IFudgeTaxonomy)">
            <summary>
            Returns the size, in bytes, of the the object if encoded with a given taxonomy. The size is calculated by <c>ComputeSize</c> and cached by this method.
            </summary>
            <param name="taxonomy">the taxonomy to use for encoding, or null to calculate the size without a taxonomy</param>
            <returns>the size of the encoded object in bytes</returns>
        </member>
        <member name="M:Fudge.FudgeEncodingObject.ComputeSize(Fudge.Taxon.IFudgeTaxonomy)">
            <summary>
            Calculates the size, in bytes, of the object if encoded with a given taxonomy. Do not call this directly to get the object size - use <c>GetSize</c> instead.
            </summary>
            <param name="taxonomy">the taxonomy to use for encoding, or null to calculate the size without a taxonomy</param>
            <returns>the size of the encoded object in bytes</returns>
        </member>
        <member name="T:Fudge.FudgeExtensions">
            <summary>
            Extension methods for core Fudge types.
            </summary>
        </member>
        <member name="M:Fudge.FudgeExtensions.AddIfNotNull(Fudge.IAppendingFudgeFieldContainer,System.String,System.Object)">
            <summary>
            Adds a field to a message, unless the value is null.
            </summary>
            <param name="msg">Message to contain the field.</param>
            <param name="name">Name of field to add.</param>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:Fudge.FudgeExtensions.AddIfNotNull(Fudge.IAppendingFudgeFieldContainer,System.Int32,System.Object)">
            <summary>
            Adds a field to a message, unless the value is null.
            </summary>
            <param name="msg">Message to contain the field.</param>
            <param name="ordinal">Ordinal of field to add.</param>
            <param name="value">Value to add.</param>
        </member>
        <member name="M:Fudge.FudgeExtensions.AddAll``1(Fudge.IAppendingFudgeFieldContainer,System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes all the values as a sequence of fields with the same name and ordinal.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="msg">Message to write the fields.</param>
            <param name="name">Name of the fields.</param>
            <param name="values">Values to write.</param>
            <remarks><c>null</c>s in the sequence are written as Fudge <see cref="T:Fudge.Types.IndicatorType"/>s.</remarks>
        </member>
        <member name="M:Fudge.FudgeExtensions.AddAll``1(Fudge.IAppendingFudgeFieldContainer,System.Int32,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes all the values as a sequence of fields with the same name and ordinal.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="msg">Message to write the fields.</param>
            <param name="ordinal">Ordinal of the fields.</param>
            <param name="values">Values to write.</param>
            <remarks><c>null</c>s in the sequence are written as Fudge <see cref="T:Fudge.Types.IndicatorType"/>s.</remarks>
        </member>
        <member name="M:Fudge.FudgeExtensions.AddAll``1(Fudge.IAppendingFudgeFieldContainer,System.String,System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Writes all the values as a sequence of fields with the same name and ordinal.
            </summary>
            <typeparam name="T">Type of values.</typeparam>
            <param name="msg">Message to write the fields.</param>
            <param name="name">Name of the fields.</param>
            <param name="ordinal">Ordinal of the fields (may be <c>null</c>).</param>
            <param name="values">Values to write.</param>
            <remarks><c>null</c>s in the sequence are written as Fudge <see cref="T:Fudge.Types.IndicatorType"/>s.</remarks>
        </member>
        <member name="M:Fudge.FudgeExtensions.AddAll(Fudge.IAppendingFudgeFieldContainer,System.Collections.Generic.IEnumerable{Fudge.IFudgeField})">
            <summary>
            Adds all the fields in the enumerable to this message.
            </summary>
            <param name="msg">Message to add fields to.</param>
            <param name="fields">Enumerable of fields to add.</param>
        </member>
        <member name="M:Fudge.FudgeExtensions.GetString(Fudge.IFudgeField)">
            <summary>
            Convenience method to get any field value as a string.
            </summary>
            <param name="field">Field containing the value.</param>
            <returns><c>null</c> if the field value is <c>null</c>, otherwise the result of calling <see cref="M:System.Object.ToString"/> on the value.</returns>
        </member>
        <member name="T:Fudge.FudgeFieldPrefixCodec">
            <summary>
            A container for all the utilities for working with fudge field prefixes.
            </summary>
        </member>
        <member name="M:Fudge.FudgeFieldPrefixCodec.IsFixedWidth(System.Int32)">
            <summary>
            Tests if the fixed width flag is set for the field. Fixed width fields are either empty (0 bytes data),
            or the number of bytes defined by the field type. If the field is not a fixed width type, the encoded
            field will contain a width field describing its length.
            </summary>
            <param name="fieldPrefix">the field prefix byte</param>
            <returns>true iff the fixed width flag is set</returns>
        </member>
        <member name="M:Fudge.FudgeFieldPrefixCodec.HasOrdinal(System.Int32)">
            <summary>
            Tests if the ordinal flag is set for the field. If set, the encoded field will contain the 2 byte ordinal index of the field.
            </summary>
            <param name="fieldPrefix">the field prefix byte</param>
            <returns>true iff the ordinal flag is set</returns>
        </member>
        <member name="M:Fudge.FudgeFieldPrefixCodec.HasName(System.Int32)">
            <summary>
            Tests if the name flag is set for the field. If set, the encoded field will contain a textual description of the field.
            </summary>
            <param name="fieldPrefix">the field prefix byte</param>
            <returns>true iff the name flag is set</returns>
        </member>
        <member name="M:Fudge.FudgeFieldPrefixCodec.GetFieldWidthByteCount(System.Int32)">
            <summary>
            Returns the number of bytes used to encode the field's width if it is not a fixed width.
            </summary>
            <param name="fieldPrefix">the field prefix byte</param>
            <returns>the size, in bytes, of the width prefix of the fields data component</returns>
        </member>
        <member name="M:Fudge.FudgeFieldPrefixCodec.ComposeFieldPrefix(System.Boolean,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Constructs a field prefix byte with the chosen options.
            </summary>
            <param name="fixedWidth">true iff the fixed width flag is to be set</param>
            <param name="varDataSize">the size, in bytes, of the variable data for non-fixed width fields</param>
            <param name="hasOrdinal">true iff the ordinal flag is to be set</param>
            <param name="hasName">true iff the name flag is to be set</param>
            <returns>a field prefix byte</returns>
        </member>
        <member name="M:Fudge.FudgeFieldPrefixCodec.CalculateVarSizeSize(System.Int32)">
            <summary>
            Calculates the number of bytes needed to write a variable data size.
            </summary>
            <param name="varSize">Data size to write.</param>
            <returns>Number of bytes needed to write the size.</returns>
        </member>
        <member name="T:Fudge.FudgeStreamElement">
            <summary>
            <c>FudgeStreamElement</c> indicates the type of the next element in a Fudge data stream read from an
            <see cref="T:Fudge.IFudgeStreamReader"/> or written to an <see cref="T:Fudge.IFudgeStreamWriter"/>.
            </summary>
        </member>
        <member name="F:Fudge.FudgeStreamElement.NoElement">
            <summary>Indicates stream has not current element.</summary>
        </member>
        <member name="F:Fudge.FudgeStreamElement.MessageStart">
            <summary>Issued when a new outermost message is started.</summary>
        </member>
        <member name="F:Fudge.FudgeStreamElement.MessageEnd">
            <summary>Issued when an outermost message is completed.</summary>
        </member>
        <member name="F:Fudge.FudgeStreamElement.SimpleField">
            <summary>Issued when a simple (non-hierarchical) field is encountered.</summary>
        </member>
        <member name="F:Fudge.FudgeStreamElement.SubmessageFieldStart">
            <summary>Issued when a sub-Message field is encountered.</summary>
        </member>
        <member name="F:Fudge.FudgeStreamElement.SubmessageFieldEnd">
            <summary>Issued when the end of a sub-Message field is reached.</summary>
        </member>
        <member name="T:Fudge.FudgeStreamParser">
            <summary>
            A parser for <see cref="T:Fudge.FudgeMsg"/> instances which uses a <see cref="T:Fudge.Encodings.FudgeEncodedStreamReader"/>.
            </summary>
        </member>
        <member name="M:Fudge.FudgeStreamParser.#ctor(Fudge.FudgeContext)">
            <summary>
            Constructs a new <see cref="T:Fudge.FudgeStreamParser"/>.
            </summary>
            <param name="fudgeContext"></param>
        </member>
        <member name="M:Fudge.FudgeStreamParser.Parse(System.IO.Stream)">
            <summary>
            Parses a given stream.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:Fudge.FudgeStreamParser.Parse(System.IO.BinaryReader)">
            <summary>
            Parses data from a given <see cref="T:System.IO.BinaryReader"/>.
            </summary>
            <param name="binaryReader"></param>
            <returns></returns>
        </member>
        <member name="M:Fudge.FudgeStreamParser.ProcessFields(Fudge.IFudgeStreamReader,Fudge.FudgeMsg)">
            @param reader
            @param msg
        </member>
        <member name="P:Fudge.FudgeStreamParser.FudgeContext">
            <summary>
            Gets the <see cref="P:Fudge.FudgeStreamParser.FudgeContext"/> used by the parser.
            </summary>
        </member>
        <member name="T:Fudge.IAppendingFudgeFieldContainer">
            <summary>
            Interface implemented by containers that allow fields to be added.
            </summary>
        </member>
        <member name="M:Fudge.IAppendingFudgeFieldContainer.Add(Fudge.IFudgeField)">
            <summary>
            Adds a field to this message.
            </summary>
            <param name="field">field to add</param>
        </member>
        <member name="M:Fudge.IAppendingFudgeFieldContainer.Add(System.String,System.Object)">
            <summary>
            Adds a field to this message.
            </summary>
            <param name="name">name of the field</param>
            <param name="value">value of the field</param>
        </member>
        <member name="M:Fudge.IAppendingFudgeFieldContainer.Add(System.Nullable{System.Int32},System.Object)">
            <summary>
            Adds a field to this message.
            </summary>
            <param name="ordinal">ordinal index of the field</param>
            <param name="value">value of the field</param>
        </member>
        <member name="M:Fudge.IAppendingFudgeFieldContainer.Add(System.String,System.Nullable{System.Int32},System.Object)">
            <summary>
            Adds a field to this message.
            </summary>
            <param name="name">name of the field, or null if no name is specified</param>
            <param name="ordinal">ordinal index of the field, or null if no index is specified</param>
            <param name="value">value of the field</param>
        </member>
        <member name="M:Fudge.IAppendingFudgeFieldContainer.Add(System.String,System.Nullable{System.Int32},Fudge.FudgeFieldType,System.Object)">
            <summary>
            Adds a field to this message with an explicit type.
            </summary>
            <param name="name">name of the field, or null if no name is specified</param>
            <param name="ordinal">ordinal index of the field, or null if no index is specified</param>
            <param name="type">explicit type of the field</param>
            <param name="value">value of the field</param>
        </member>
        <member name="T:Fudge.Serialization.MessageFudgeDeserializationContext">
            <summary>
            Provides an optimized implementation of <see cref="T:Fudge.Serialization.FudgeDeserializationContext"/> which operates on a <see cref="T:Fudge.FudgeMsg"/>.
            This allows for significantly reduced memory usage.
            </summary>
            <remarks>
            You should not need to use this class directly. <see cref="M:Fudge.Serialization.FudgeSerializer.Deserialize``1(Fudge.FudgeMsg)"/>
            </remarks>
        </member>
        <member name="T:Fudge.Serialization.FudgeDeserializationContext">
            <summary>
            Provides an implementation of <see cref="T:Fudge.Serialization.IFudgeDeserializer"/> used by the <see cref="T:Fudge.Serialization.FudgeSerializer"/>.
            </summary>
            <remarks>
            You should not need to use this class directly.
            </remarks>
        </member>
        <member name="T:Fudge.Serialization.IFudgeDeserializer">
            <summary>
            <c>IFudgeDeserializer</c> is the interface through which objects being deserialized access the serialization framework.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.IFudgeDeserializer.FromField``1(Fudge.IFudgeField)">
            <summary>
            Deserialises an object from a Fudge field.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="field">Field containing either a reference to the object as an integer, or the object serialised as a <c>FudgeMsg</c></param>
            <returns>Deserialised object</returns>
            <remarks>
            This method allows the deserialiser to be agnostic to whether the object was serialised as a reference or in-place.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.IFudgeDeserializer.FromField(Fudge.IFudgeField,System.Type)">
            <summary>
            Deserialises an object from a Fudge field.
            </summary>
            <param name="field">Field containing either a reference to the object as an integer, or the object serialised as a <c>FudgeMsg</c></param>
            <param name="type">Expected type of the object</param>
            <returns>Deserialised object</returns>
            <remarks>
            This method allows the deserialiser to be agnostic to whether the object was serialised as a reference or in-place.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.IFudgeDeserializer.Register(Fudge.IFudgeFieldContainer,System.Object)">
            <summary>
            Registers a partially-constructed object in case of reference cycles.
            </summary>
            <param name="msg">Message from which the object was deserialized.</param>
            <param name="obj">Object to register with the context.</param>
            <remarks>
            <para>
            Every new object must be registered after construction, and this process is usually
            performed by the surrogate (implementing <see cref="T:Fudge.Serialization.IFudgeSerializationSurrogate"/>)
            which performs the deserialization.  It is essential to register the new object
            before trying to deserialize any sub-objects which may potentially contain references
            back to this one (i.e. where there are cycles in the object graph).  The surrogate
            will usually therefore register the object immediately after construction and before any
            fields are deserialized.
            </para>
            <para>
            Failing to register a new object will cause an exception to be thrown by the serialization
            framework.  However, when using automatic (reflection-based) surrogates (e.g. when a class
            has a default constructor and implements <see cref="T:Fudge.Serialization.IFudgeSerializable"/> then this is
            done automatically.
            </para>
            </remarks>
        </member>
        <member name="P:Fudge.Serialization.IFudgeDeserializer.Context">
            <summary>
            Gets the <see cref="T:Fudge.FudgeContext"/> for this deserializer.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.FudgeDeserializationContext.FromField``1(Fudge.IFudgeField)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.FudgeDeserializationContext.FromField(Fudge.IFudgeField,System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.FudgeDeserializationContext.Register(Fudge.IFudgeFieldContainer,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.FudgeDeserializationContext.WalkMessage(Fudge.FudgeMsg)">
            <summary>
            Finds all the sub-messages in advance so we know their indices and can deserialize out of order if needed
            </summary>
        </member>
        <member name="M:Fudge.Serialization.FudgeDeserializationContext.GetFromRef(System.Nullable{System.Int32},System.Type)">
            <summary>
            Get the real object from a reference ID
            </summary>
            <remarks>It is possible that the reference has not yet been deserialized if (for example) it is a child of
            an object that has evolved elsewhere but where in this version that field has not been read.</remarks>
        </member>
        <member name="P:Fudge.Serialization.FudgeDeserializationContext.Context">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Serialization.Reflection.DataContractSurrogate">
            <summary>
            Handles serialization and deserialization of classes that have been written with
            the WCF <c>[DataContract]</c> marker.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.IFudgeSerializationSurrogate">
            <summary>
            <c>IFudgeSerializationSurrogate</c> performs the serialization and deserialization on behalf of another class.
            </summary>
            <remarks>
            A surrogate is typically used in situations where the main class cannot be modified, where there is a desire to
            keep Fudge-related code separate from the main code base, or where a class is immutable (so all deserialized data
            must be collected before construction).  It is also necessary if an object may contain sub-objects that could
            create a circular reference, as the parent object must be registered with <see cref="M:Fudge.Serialization.IFudgeDeserializer.Register(Fudge.IFudgeFieldContainer,System.Object)"/>
            post-construction but before the sub-objects are deserialized.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.IFudgeSerializationSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <summary>
            Serializes the given object to a Fudge serializer.
            </summary>
            <param name="obj">Object to serialize.</param>
            <param name="msg">Message into which the data should be serialized.</param>
            <param name="serializer">Serializer controlling the serialization process.</param>
        </member>
        <member name="M:Fudge.Serialization.IFudgeSerializationSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <summary>
            Deserializes a message into a new object.
            </summary>
            <param name="msg">Message to deserialize from.</param>
            <param name="deserializer">Deserializer controlling the deserialization process.</param>
            <returns>Newly constructed and initialized object.</returns>
            <remarks>
            The surrogate must register the new object by calling <see cref="M:Fudge.Serialization.IFudgeDeserializer.Register(Fudge.IFudgeFieldContainer,System.Object)"/>
            as soon after construction as possible to make the object available for any references
            back from contained objects.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DataContractSurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new instance for a specific type
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> for this surrogate.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> describing the type to serialize.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DataContractSurrogate.CanHandle(Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Determines whether a given type can be serialized with this class.
            </summary>
            <param
            name="typeData">Type to test.</param>
            <returns><c>true</c> if this class can handle the type.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DataContractSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DataContractSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Serialization.Reflection.DotNetSerializationSurrogateSurrogate">
            <summary>
            Surrogate that uses an <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> from the .net serialization framework
            to do the serialization and deserialization.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DotNetSerializationSurrogateSurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData,System.Runtime.Serialization.ISerializationSurrogate,System.Runtime.Serialization.ISurrogateSelector)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.Reflection.DotNetSerializationSurrogateSurrogate"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type for this surrogate.</param>
            <param name="surrogate">Surrogate that maps the object to or from a <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.</param>
            <param name="selector">Selector that produced the surrogate.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DotNetSerializationSurrogateSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DotNetSerializationSurrogateSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Serialization.Reflection.DotNetSerializationSurrogateSurrogate.SerializationSurrogate">
            <summary>
            Gets the .net <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> that will perform the serialization and deserialization.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.Reflection.DotNetSerializableSurrogate">
            <summary>
            Surrogate for classes implementing <see cref="T:System.Runtime.Serialization.ISerializable"/> from .net serialization.
            </summary>
            <remarks>
            NOTE that when deserializing data that has not been serialized through <see cref="T:System.Runtime.Serialization.ISerializable"/> (e.g.
            recieved from another platform, fields which are <c>null</c> may have been omitted.  Using the normal
            methods of <see cref="T:System.Runtime.Serialization.SerializationInfo"/> such as <see cref="M:System.Runtime.Serialization.SerializationInfo.GetString(System.String)"/> will throw
            an exception in this situation as the field is missing.  The only way around this is to use
            <see cref="M:System.Runtime.Serialization.SerializationInfo.GetEnumerator"/> to process the data instead.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DotNetSerializableSurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.Reflection.DotNetSerializableSurrogate"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type for this surrogate.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DotNetSerializableSurrogate.CanHandle(Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Detects whether a given type can be serialized with this class.
            </summary>
            <param
            name="typeData">Type to test.</param>
            <returns><c>true</c> if this class can handle the type.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DotNetSerializableSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DotNetSerializableSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Serialization.Reflection.ImmutableSurrogate">
            <summary>
            Surrogate for immutable objects - i.e. ones that have getters plus a rich constructor that matches the getters
            </summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ImmutableSurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.Reflection.ImmutableSurrogate"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type for this surrogate.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ImmutableSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ImmutableSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ImmutableSurrogate.MatchConstructor(System.Reflection.ConstructorInfo,Fudge.Serialization.Reflection.TypeData.PropertyData[])">
            <summary>
            Checks if a constructor matches the set of properties, and initialised data about the constructor parameters at the same time.
            </summary>
            <param name="constructor">Constructor to test.</param>
            <param name="properties">Properties to match against.</param>
            <returns>Constructor parameter info, or <c>null</c> if no match.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ReflectionUtil.CreateStaticMethodDelegate``1(System.Type,System.String,System.Type[])">
            <summary>
            Creates a delegate for a static method after specializing its generic types.
            </summary>
            <typeparam name="T">Type of delegate to create.</typeparam>
            <param name="type">Type that method is on</param>
            <param name="name">Name of method to find.</param>
            <param name="genericTypes">Array of types to apply to the generic parameters of the method.</param>
            <returns>Delegate that calls the specialized method.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ReflectionUtil.CreateInstanceMethodDelegate``1(System.Object,System.String,System.Type[])">
            <summary>
            Creates a delegate for a method after specializing its generic types.
            </summary>
            <typeparam name="T">Type of delegate to create.</typeparam>
            <param name="obj">Instance that methods will be called on</param>
            <param name="name">Name of method to find.</param>
            <param name="genericTypes">Array of types to apply to the generic parameters of the method.</param>
            <returns>Delegate that calls the specialized method.</returns>
        </member>
        <member name="T:Fudge.Serialization.Reflection.SerializableAttributeSurrogate">
            <summary>
            Handles serialization and deserialization of classes that are marked with <see cref="T:System.SerializableAttribute"/>
            but do not implement <see cref="T:System.Runtime.Serialization.ISerializable"/>.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.SerializableAttributeSurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.Reflection.SerializableAttributeSurrogate"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type for this surrogate.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.SerializableAttributeSurrogate.CanHandle(Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Detects whether a given type can be serialized with this class.
            </summary>
            <param
            name="typeData">Type to test.</param>
            <returns><c>true</c> if this class can handle the type.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.SerializableAttributeSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.SerializableAttributeSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Serialization.ReaderFudgeDeserializationContext">
            <summary>
            Provides an implementation of <see cref="T:Fudge.Serialization.FudgeDeserializationContext"/> which reads from arbitrary <see cref="T:Fudge.IFudgeStreamReader"/>s
            </summary>
            <remarks>
            You should not need to use this class directly. <see cref="M:Fudge.Serialization.FudgeSerializer.Deserialize(Fudge.IFudgeStreamReader)"/>
            </remarks>
            <notes>
            REVIEW 2011-06-27 simon-og -- The message walking could be done whilst deserializing, but for cases where we read from a <see cref="T:System.IO.MemoryStream"/> this seems to be slower
            </notes>
        </member>
        <member name="T:Fudge.Util.FudgeStreamPipe">
            <summary>
            <c>FudgeStreamPipe</c> is used to automatically push all data read from an input data stream via an <see cref="T:Fudge.IFudgeStreamReader"/>
            to an output data stream via an <see cref="T:Fudge.IFudgeStreamWriter"/>.
            </summary>
        </member>
        <member name="M:Fudge.Util.FudgeStreamPipe.#ctor(Fudge.IFudgeStreamReader,Fudge.IFudgeStreamWriter)">
            <summary>
            Constructs a new pipe from an <see cref="T:Fudge.IFudgeStreamReader"/> to an <see cref="T:Fudge.IFudgeStreamWriter"/>.
            </summary>
            <param name="reader"><see cref="T:Fudge.IFudgeStreamReader"/> from which to fetch the data.</param>
            <param name="writer"><see cref="T:Fudge.IFudgeStreamWriter"/> to output the data.</param>
        </member>
        <member name="M:Fudge.Util.FudgeStreamPipe.Process">
            <summary>
            Passes all elements from the <see cref="T:Fudge.IFudgeStreamReader"/> to the <see cref="T:Fudge.IFudgeStreamWriter"/> until the
            reader indicates it has no more data.
            </summary>
            <remarks>
            If the reader is processing an asynchronous source (e.g. a socket) then <c>Process()</c> may block whilst the
            reader is waiting for data.
            </remarks>
        </member>
        <member name="M:Fudge.Util.FudgeStreamPipe.Abort">
            <summary>
            Stops the pipe processing any further
            </summary>
        </member>
        <member name="M:Fudge.Util.FudgeStreamPipe.ProcessOne">
            <summary>
            Reads the next complete message from the <see cref="T:Fudge.IFudgeStreamReader"/> and sends it to the <see cref="T:Fudge.IFudgeStreamWriter"/>.
            </summary>
        </member>
        <member name="E:Fudge.Util.FudgeStreamPipe.MessageProcessed">
            <summary>
            MessageProcessed is fired whenever a complete message has been processed by the writer.
            </summary>
        </member>
        <member name="T:Fudge.FudgeFieldType">
            <summary>
            The class defining the type of a particular field.
            While Fudge comes with a set of required types which are fully supported
            in all Fudge-compliant systems, if you have custom data, you can control the encoding
            using your own instance of <see cref="T:Fudge.FudgeFieldType"/>, making sure to register the
            instance with the <see cref="T:Fudge.FudgeTypeDictionary"/> at application startup.
            
            </summary>
        </member>
        <member name="M:Fudge.FudgeFieldType.#ctor(System.Int32,System.Type,System.Boolean,System.Int32)">
            <summary>
            Creates a new <c>FudgeFieldType</c> mapped to an underlying .NET type that can hold the data.
            </summary>
            <param name="typeId">the numeric identifier to use when encoding this type, must be between 0 and 255</param>
            <param name="csharpType">an underlying .NET type to hold the field data</param>
            <param name="isVariableSize">set to true if the type can't be encoded with a fixed width</param>
            <param name="fixedSize">if the field can be encoded with a fixed width, the number of bytes required to encode it</param>
        </member>
        <member name="M:Fudge.FudgeFieldType.Minimize(System.Object,Fudge.FudgeFieldType@)">
            <summary>
            Override <c>Minimize</c> where you wish to be able to reduce to a lower type as fields are added to messages.
            </summary>
            <remarks>
            <c>Minimize</c> is used to reduce integers to their smallest form, but can also be used to convert
            non-primitive types (e.g. GUID) to primitive ones (e.g. byte[16]) as they are added.
            </remarks>
            <param name="value">Value to reduce.</param>
            <param name="type">Current field type - update this if you minimize to a different type.</param>
            <returns>Minimized value.</returns>
        </member>
        <member name="M:Fudge.FudgeFieldType.ConvertValueFrom(System.Object)">
            <summary>
            Converts a value of another type to one of this field type, if possible.
            </summary>
            <remarks>
            Override this to provide custom conversions.  The default behaviour is to use the default .net conversions.
            </remarks>
            <param name="value">Value to convert.</param>
            <returns>Converted value.</returns>
            <exception cref="T:System.InvalidCastException">Thrown if the value cannot be converted</exception>
        </member>
        <member name="M:Fudge.FudgeFieldType.Equals(System.Object)">
            <summary>
            Tests if this object is equal to another. Two <c>FudgeFieldType</c>s are equal iff they have the same numeric type identifier.
            </summary>
            <param name="obj">the object to compare to</param>
            <returns>true iff the objects are equal</returns>
        </member>
        <member name="M:Fudge.FudgeFieldType.GetHashCode">
            <inheritdoc cref="M:System.Object.GetHashCode"/>
        </member>
        <member name="M:Fudge.FudgeFieldType.GenerateToString">
            <summary>
            Returns a string representation of this type. Override this in preference to <c>ToString</c> as it
            will only be called once at object construction time. The default <c>ToString</c> method returns
            this cached value.
            </summary>
            <returns>string representation</returns>
        </member>
        <member name="M:Fudge.FudgeFieldType.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Fudge.FudgeFieldType.GetVariableSize(System.Object,Fudge.Taxon.IFudgeTaxonomy)">
            <summary>
            Calculates the size of an encoded value. This method must be provided for any variable size types.
            </summary>
            <param name="value">the value to calculate the size for</param>
            <param name="taxonomy">the taxonomy to encode against</param>
            <returns>the size in bytes of the encoded value</returns>
        </member>
        <member name="M:Fudge.FudgeFieldType.WriteValue(System.IO.BinaryWriter,System.Object)">
            <summary>
            Writes a values to an output <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="output"><see cref="T:System.IO.BinaryWriter"/> to write the data to.</param>
            <param name="value">Value to write.</param>
        </member>
        <member name="M:Fudge.FudgeFieldType.ReadValue(System.IO.BinaryReader,System.Int32)">
            <summary>
            Reads a values from an input <see cref="T:System.IO.BinaryReader"/>.
            </summary>
            <param name="input"><see cref="T:System.IO.BinaryReader"/> to read the data from.</param>
            <param name="dataSize">Number of bytes for the data representation.</param>
            <returns>Decoded object.</returns>
        </member>
        <member name="P:Fudge.FudgeFieldType.TypeId">
            <summary>
            Gets the numeric identifier assigned to this type
            </summary>
            <remarks>See <see cref="T:Fudge.FudgeTypeDictionary"/> for defined identifiers.</remarks>
        </member>
        <member name="P:Fudge.FudgeFieldType.CSharpType">
            <summary>
            Gets the underlying .NET type 
            </summary>
        </member>
        <member name="P:Fudge.FudgeFieldType.IsVariableSize">
            <summary>
            Gets whether the field can have variable length. If this attribute is false the field can be encoded with a fixed width.
            </summary>
        </member>
        <member name="P:Fudge.FudgeFieldType.FixedSize">
            <summary>
            Gets the size in bytes of a fixed width field.
            </summary>
        </member>
        <member name="T:Fudge.FudgeValueMinimizer`1">
            <summary>
            <c>FudgeValueMinimizer</c> is used to reduce values to their most primitive form for encoding
            </summary>
            <remarks>
            The minimizer may simply return the original value.  If it converts to another type then it should update the <c>type</c> parameter also.
            </remarks>
            <typeparam name="T">Type of value to minimize.</typeparam>
            <param name="value">Value to minimize.</param>
            <param name="type">Current <see cref="T:Fudge.FudgeFieldType"/>, which may be updated by the minimizer.</param>
            <returns>Minimized value.</returns>
        </member>
        <member name="T:Fudge.FudgeFieldType`1">
            <summary>Unlike in Fudge-Java, here we have to have a generic type inheriting from the non-generic base type, as C# doesn't support MyClass&lt;?&gt;</summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:Fudge.FudgeFieldType`1.#ctor(System.Int32,System.Boolean,System.Int32)">
            <summary>
            Cosntructs a new <c>FudgeFieldType</c>.
            </summary>
            <param name="typeId">ID of the type, as defined at http://wiki.fudgemsg.org/display/FDG/Types</param>
            <param name="isVariableSize">If true then the size of the binary representation depends upon the value (e.g. a string).</param>
            <param name="fixedSize">If not variable sized, then the number of bytes to encode values of this type.</param>
        </member>
        <member name="M:Fudge.FudgeFieldType`1.#ctor(System.Int32,System.Boolean,System.Int32,Fudge.FudgeValueMinimizer{`0})">
            <summary>
            Cosntructs a new <c>FudgeFieldType</c> but with a minimizer function.
            </summary>
            <param name="typeId">ID of the type, as defined at http://wiki.fudgemsg.org/display/FDG/Types</param>
            <param name="isVariableSize">If true then the size of the binary representation depends upon the value (e.g. a string).</param>
            <param name="fixedSize">If not variable sized, then the number of bytes to encode values of this type.</param>
            <param name="minimizer">Function used to reduce values of this type to their canonical form.</param>
            <remarks>Minimization functions are used for example to reduce integers down to their smallest form.</remarks>
        </member>
        <member name="M:Fudge.FudgeFieldType`1.GetVariableSize(`0,Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeFieldType`1.WriteValue(System.IO.BinaryWriter,`0)">
            <summary>
            Override this method to write a typed value to an output <see cref="T:System.IO.BinaryWriter"/>.
            </summary>
            <param name="output"><see cref="T:System.IO.BinaryWriter"/> to use to output data.</param>
            <param name="value">Value to write.</param>
            <remarks>This method provides a typed value compared to <see cref="M:Fudge.FudgeFieldType.WriteValue(System.IO.BinaryWriter,System.Object)"/>.</remarks>
        </member>
        <member name="M:Fudge.FudgeFieldType`1.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <summary>
            Override this method to read a typed value from an input <see cref="T:System.IO.BinaryReader"/>.
            </summary>
            <param name="input"><see cref="T:System.IO.BinaryReader"/> to read data from.</param>
            <param name="dataSize">The number of bytes to read from the <see cref="T:System.IO.BinaryReader"/>.</param>
            <returns>Decoded object.</returns>
            <remarks>This method is a typed version of <see cref="M:Fudge.FudgeFieldType.ReadValue(System.IO.BinaryReader,System.Int32)"/>.</remarks>
        </member>
        <member name="M:Fudge.FudgeFieldType`1.Minimize(System.Object,Fudge.FudgeFieldType@)">
            <summary>
            Attempts to reduce a value to a more primitive type using the minimizer delegate.
            </summary>
            <param name="type">value to minimise</param>
            <param name="value">type of the value - will be updated if a reduction takes place</param>
            <returns>reduced value, or the original value if no reduction is possible</returns>
        </member>
        <member name="M:Fudge.FudgeFieldType`1.GetVariableSize(System.Object,Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeFieldType`1.WriteValue(System.IO.BinaryWriter,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeFieldType`1.ReadValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Fudge.FudgeMsg">
            <summary>
            A container for <see cref="T:Fudge.FudgeMsgField"/>s.
            This instance will contain all data fully extracted from a Fudge-encoded
            stream, unlike other systems where fields are unpacked as required.
            Therefore, constructing a <c>FudgeMsg</c> from a field is relatively more
            expensive in CPU and memory usage than just holding the original byte array,
            but lookups are substantially faster.
            </summary>
            <remarks>
            The various <c>Get*()</c> methods will return <c>null</c> if the field is not
            found, and otherwise use standard conversions to map between types, throwing
            <see cref="T:System.InvalidCastException"/> and <see cref="T:System.OverflowException"/> as
            appropriate.
            </remarks>
        </member>
        <member name="T:Fudge.IMutableFudgeFieldContainer">
            <summary>
            Defines a set of fields that can be modified as well as inspected.
            </summary>
        </member>
        <member name="M:Fudge.FudgeMsg.#ctor(Fudge.FudgeContext)">
            <summary>
            Constructs a new <see cref="T:Fudge.FudgeMsg"/> using a given <see cref="T:Fudge.FudgeContext"/>.
            </summary>
            <param name="context">Context to use for the message.</param>
        </member>
        <member name="M:Fudge.FudgeMsg.#ctor(Fudge.FudgeMsg)">
            <summary>
            Creates a new <c>FudgeMsg</c> object as a copy of another.
            </summary>
            <param name="other">an existing <c>FudgeMsg</c> object to copy</param>
        </member>
        <member name="M:Fudge.FudgeMsg.#ctor(Fudge.IFudgeField[])">
            <summary>
            Constructs a new <see cref="T:Fudge.FudgeMsg"/> using a default context, and populates with a set of fields.
            </summary>
            <param name="fields">Fields to populate the message.</param>
        </member>
        <member name="M:Fudge.FudgeMsg.#ctor(Fudge.FudgeContext,Fudge.IFudgeField[])">
            <summary>
            Constructs a new <see cref="T:Fudge.FudgeMsg"/> using a given context, and populates with a set of fields.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use for the message.</param>
            <param name="fields">Fields to populate the message.</param>
        </member>
        <member name="M:Fudge.FudgeMsg.InitializeFromByteArray(System.Byte[])">
            <summary>
            Populates the message fields from the encoded data. If the array is larger than the Fudge envelope, any additional data is ignored.
            </summary>
            <param name="byteArray">the encoded data to populate this message with</param>
        </member>
        <member name="M:Fudge.FudgeMsg.Add(Fudge.IFudgeField)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.Add(System.String,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.Add(System.Nullable{System.Int32},System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.Add(System.String,System.Nullable{System.Int32},System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.Add(System.String,System.Nullable{System.Int32},Fudge.FudgeFieldType,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.AddAll``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds all the values in the enumerable to this message as fields of a given name.
            </summary>
            <param name="name">Name of the field.</param>
            <param name="values">Enumerable of values to add.</param>
        </member>
        <member name="M:Fudge.FudgeMsg.AddAll``1(System.Int32,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds all the values in the enumerable to this message as fields with a given ordinal.
            </summary>
            <param name="ordinal">Ordinal of the field.</param>
            <param name="values">Enumerable of values to add.</param>
        </member>
        <member name="M:Fudge.FudgeMsg.GetNumFields">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAllFields">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAllFieldNames">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetByIndex(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAllByOrdinal(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetByOrdinal(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAllByName(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetByName(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAllValues``1(System.String)">
            <summary>
            Returns the values of all fields with a given name as a specific type.
            </summary>
            <typeparam name="T">Type to return values as.</typeparam>
            <param name="name">Name of fields to get.</param>
            <returns>List of values of the given type.</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetAllValues``1(System.Int32)">
            <summary>
            Returns the values of all fields with a given ordinal as a specific type.
            </summary>
            <typeparam name="T">Type to return values as.</typeparam>
            <param name="ordinal">Ordinal of fields to get.</param>
            <returns>List of values of the given type.</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue``1(System.String)">
            <inheritdoc cref="M:Fudge.IFudgeFieldContainer.GetValue``1(System.String)"/>
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue(System.String,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue``1(System.Int32)">
            <inheritdoc cref="M:Fudge.IFudgeFieldContainer.GetValue``1(System.Int32)"/>
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue(System.Int32,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue(System.String,System.Nullable{System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetIndex(System.String,System.Nullable{System.Int32})">
            <summary>
            Finds ths index of the first field with matching name or ordinal.
            </summary>
            <param name="name">Name of field, or <c>null</c> to match on ordinal.</param>
            <param name="ordinal">Ordinal of field, or <c>null</c> to match on name.</param>
            <returns>Index of first matching field, or <c>-1</c> if not found.</returns>
            <remarks>If the ordinal matches, the name is not compared.</remarks>
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})">
            <inheritdoc cref="M:Fudge.IFudgeFieldContainer.GetValue``1(System.String,System.Nullable{System.Int32})"/>
        </member>
        <member name="M:Fudge.FudgeMsg.GetValue(System.String,System.Nullable{System.Int32},System.Type)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetDouble(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetDouble(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAsDoubleInternal(System.String,System.Nullable{System.Int32})">
            <summary>
            Internal implementation for GetDouble methods using the behaviour of <see cref="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})"/>.
            </summary>
            <param name="fieldName">field name, or null to search by ordinal only</param>
            <param name="ordinal">ordinal index, or null to search by field name only</param>
            <returns>field value cast as a double</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetFloat(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetFloat(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAsFloatInternal(System.String,System.Nullable{System.Int32})">
            <summary>
            Internal implementation for GetFloat methods using the behaviour of <see cref="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})"/>.
            </summary>
            <param name="fieldName">field name, or null to search by ordinal only</param>
            <param name="ordinal">ordinal index, or null to search by field name only</param>
            <returns>field value cast as a float</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetLong(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetLong(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAsLongInternal(System.String,System.Nullable{System.Int32})">
            <summary>
            Internal implementation for GetLong methods using the behaviour of <see cref="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})"/>.
            </summary>
            <param name="fieldName">field name, or null to search by ordinal only</param>
            <param name="ordinal">ordinal index, or null to search by field name only</param>
            <returns>field value cast as a long</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetInt(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetInt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAsIntInternal(System.String,System.Nullable{System.Int32})">
            <summary>
            Internal implementation for GetIntmethods using the behaviour of <see cref="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})"/>.
            </summary>
            <param name="fieldName">field name, or null to search by ordinal only</param>
            <param name="ordinal">ordinal index, or null to search by field name only</param>
            <returns>field value cast as an int</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetShort(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetShort(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAsShortInternal(System.String,System.Nullable{System.Int32})">
            <summary>
            Internal implementation for GetShort methods using the behaviour of <see cref="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})"/>.
            </summary>
            <param name="fieldName">field name, or null to search by ordinal only</param>
            <param name="ordinal">ordinal index, or null to search by field name only</param>
            <returns>field value cast as a short</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetSByte(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetSByte(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAsSByteInternal(System.String,System.Nullable{System.Int32})">
            <summary>
            Internal implementation for GetSByte methods using the behaviour of <see cref="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})"/>.
            </summary>
            <param name="fieldName">field name, or null to search by ordinal only</param>
            <param name="ordinal">ordinal index, or null to search by field name only</param>
            <returns>field value cast as a sbyte</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetBoolean(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetBoolean(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAsBooleanInternal(System.String,System.Nullable{System.Int32})">
            <summary>
            Internal implementation for GetBoolean methods using the behaviour of <see cref="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})"/>.
            </summary>
            <param name="fieldName">field name, or null to search by ordinal only</param>
            <param name="ordinal">ordinal index, or null to search by field name only</param>
            <returns>field value cast as a boolean</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetString(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetString(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetMessage(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetMessage(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetAsStringInternal(System.String,System.Nullable{System.Int32})">
            <summary>
            Internal implementation for GetString methods using the behaviour of <see cref="M:Fudge.FudgeMsg.GetValue``1(System.String,System.Nullable{System.Int32})"/>.
            </summary>
            <param name="fieldName">field name, or null to search by ordinal only</param>
            <param name="ordinal">ordinal index, or null to search by field name only</param>
            <returns>field value cast as a string</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.ToByteArray">
            <summary>
            Returns the Fudge encoded form of this <c>FudgeMsg</c> as a <c>byte</c> array without a taxonomy reference.
            </summary>
            <returns>an array containing the encoded message</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.ComputeSize(Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetFirstTypedValue(System.String,System.Int32)">
            <summary>
            Returns the value of the first field with a given name and type identifier.
            </summary>
            <param name="fieldName">field name</param>
            <param name="typeId">type identifier</param>
            <returns>the matching field, or null if none is found</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.GetFirstTypedValue(System.Int32,System.Int32)">
            <summary>
            Returns the value of the first field with a given ordinal index and type identifier.
            </summary>
            <param name="ordinal">ordinal index</param>
            <param name="typeId">type identifier</param>
            <returns>matching field, or null if none found</returns>
        </member>
        <member name="M:Fudge.FudgeMsg.SetNamesFromTaxonomy(Fudge.Taxon.IFudgeTaxonomy)">
            <summary>
            Updates any fields which have an ordinal index only to include a field name if one is available in the taxonomy. The
            same taxonomy is passed to any submessages.
            </summary>
            <param name="taxonomy">taxonomy to set field names from</param>
        </member>
        <member name="M:Fudge.FudgeMsg.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Fudge.FudgeMsg.GetFastFields">
            <summary>
            A fast version of <see cref="M:Fudge.FudgeMsg.GetEnumerator"/>, 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fudge.FudgeMsg.ToString">
            <summary>
            Returns a string representation of this message.
            </summary>
            <returns>string representation</returns>
        </member>
        <member name="P:Fudge.FudgeMsg.Context">
            <summary>
            Gets the <see cref="T:Fudge.FudgeContext"/> for this message.
            </summary>
        </member>
        <member name="T:Fudge.FudgeMsgEnvelope">
            <summary>
            Wraps a <see cref="T:Fudge.FudgeMsg"/> for the purpose of encoding the envelope header.
            This is the object which is encoded for a top-level fudge message; sub-messages don't
            contain a separate envelope.
            </summary>
        </member>
        <member name="M:Fudge.FudgeMsgEnvelope.#ctor">
            <summary>
            Constructs a new envelope containing an emtpy message.
            </summary>
        </member>
        <member name="M:Fudge.FudgeMsgEnvelope.#ctor(Fudge.FudgeMsg)">
            <summary>
            Creates a new <c>FudgeMsgEnvelope</c> around an existing <c>FudgeMsg</c>.
            </summary>
            <param name="msg">message contained within the envelope</param>
        </member>
        <member name="M:Fudge.FudgeMsgEnvelope.#ctor(Fudge.FudgeMsg,System.Int32)">
            <summary>
            Creates a new <c>FudgeMsgEnvelope</c> around an existing <c>FudgeMsg</c> with a specific encoding schema version. The default
            schema version is 0.
            </summary>
            <param name="message">message contained within the envelope</param>
            <param name="version">schema version, 0 to 255</param>
        </member>
        <member name="M:Fudge.FudgeMsgEnvelope.ComputeSize(Fudge.Taxon.IFudgeTaxonomy)">
            <summary>
            Calculates the total size of the envelope. This is the encoded size of the message within the envelope plus the 8 byte envelope header.
            </summary>
            <param name="taxonomy">optional taxonomy to encode the message with</param>
            <returns>total size in bytes</returns>
        </member>
        <member name="P:Fudge.FudgeMsgEnvelope.Message">
            <summary>
            Gets the message contained within this envelope.
            </summary>
        </member>
        <member name="P:Fudge.FudgeMsgEnvelope.Version">
            <summary>
            Gets the schema version of the envelope.
            </summary>
        </member>
        <member name="T:Fudge.FudgeMsgField">
            <summary>
            A concrete implementation of <see cref="T:Fudge.IFudgeField"/> suitable for inclusion in
            a pre-constructed <see cref="T:Fudge.FudgeMsg"/> or a stream of data.
            </summary>
        </member>
        <member name="M:Fudge.FudgeMsgField.#ctor(Fudge.FudgeFieldType,System.Object,System.String,System.Nullable{System.Int16})">
            <summary>
            Creates a new message field.
            </summary>
            <param name="type">field data type</param>
            <param name="value">field value</param>
            <param name="name">field name, or null for no field name</param>
            <param name="ordinal">ordinal index, or null for no ordinal index</param>
        </member>
        <member name="M:Fudge.FudgeMsgField.#ctor(Fudge.IFudgeField)">
            <summary>
            Creates a new message field from an existing field.
            </summary>
            <param name="field">an existing field to copy</param>
        </member>
        <member name="M:Fudge.FudgeMsgField.Clone">
            <inheritdoc cref="M:System.ICloneable.Clone"/>
        </member>
        <member name="M:Fudge.FudgeMsgField.ToString">
            <inheritdoc cref="M:System.Object.ToString"/>
        </member>
        <member name="M:Fudge.FudgeMsgField.ComputeSize(Fudge.Taxon.IFudgeTaxonomy)">
            <summary>
            Calculates the encoded size of this field in bytes. This is the encoded size of the
            underlying value as defined by the corresponding <c>FudgeFieldType</c>, the 2 byte
            field prefix, plus the ordinal index and field name if specified. If a taxonomy is
            specified and defines the field name, only the corresponding ordinal index would be
            written so the field name is not counted.
            </summary>
            <param name="taxonomy">taxonomy used to resolve field names, or null</param>
            <returns>the encoded size of this field in bytes</returns>
        </member>
        <member name="M:Fudge.FudgeMsgField.toIFudgeField(Fudge.FudgeMsgField)">
            <summary>
            Helper function for converting to a base interface to satisfy C# type checking rules on collections. Can be used, for
            example, to turn a List&lt;FudgeMsgField&gt; into a List&lt;IFudgeField&gt; using the ConvertAll method on List.
            </summary>
            <param name="f">a FudgeMsgField object</param>
            <returns>a IFudgeField object</returns>
        </member>
        <member name="P:Fudge.FudgeMsgField.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Fudge.FudgeMsgField.Value">
            <summary>
            Gets the value of this field.
            </summary>
        </member>
        <member name="P:Fudge.FudgeMsgField.Ordinal">
            <summary>
            Gets the ordinal index of this field. This has value null if no ordinal index is specified.
            </summary>
        </member>
        <member name="P:Fudge.FudgeMsgField.Name">
            <summary>
            Gets the descriptive name of this field. This has value null if no name is specified, e.g. if a message has not been resolved against a taxonomy.
            </summary>
        </member>
        <member name="T:Fudge.FudgeMsgFormatter">
            <summary>
            Allows for pretty-printing of <see cref="T:Fudge.FudgeMsg"/> instances.
            </summary>
        </member>
        <member name="F:Fudge.FudgeMsgFormatter.DEFAULT_INDENT">
            <summary>
            Default indentation (number of spaces) to use when formatting message components.
            </summary>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.#ctor(System.IO.TextWriter)">
            <summary>
            Creates a new pretty-printer for formatting messages.
            </summary>
            <param name="textWriter">target for text output</param>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.#ctor(System.IO.TextWriter,System.Int32)">
            <summary>
            Creates a new pretty-printer for formatting messages.
            </summary>
            <param name="writer">target for text output</param>
            <param name="indent">width of each indent (number of spaces)</param>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.Format(Fudge.IFudgeFieldContainer)">
            <summary>
            Formats a message.
            </summary>
            <param name="msg">message to format</param>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.Format(Fudge.IFudgeFieldContainer,System.Int32)">
            <summary>
            Formats a message with a given starting indent.
            </summary>
            <param name="msg">message to format</param>
            <param name="depth">starting indent</param>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.GetFieldSpecWidth(Fudge.IFudgeField,System.Int32,System.Int32)">
            <summary>
            Calculates the length of the field description (physical index, ordinal index if specified, and field name if specified).
            The length includes the indentation prefix.
            </summary>
            <param name="field">field</param>
            <param name="index">physical index within a containing message</param>
            <param name="depth">indentation level</param>
            <returns></returns>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.Format(Fudge.IFudgeField,System.Int32,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>
            Writes a line describing a field and its value. If the field is a submessage, that message is output at a deeper indentation level.
            </summary>
            <param name="field">field to output</param>
            <param name="index">physical index within containing message</param>
            <param name="depth">indentation level</param>
            <param name="fieldSpec">field description text (includes indent)</param>
            <param name="maxFieldSpecWidth">length of longest field description text (for layout)</param>
            <param name="maxTypeNameWidth">length of longest type name (for layout)</param>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.GetFieldSpec(Fudge.IFudgeField,System.Int32,System.Int32)">
            <summary>
            Returns a string describing the field with an indentation prefix. The description includes the physical index, ordinal index (if specified),
            and field name (if specified).
            </summary>
            <param name="field">field</param>
            <param name="index">physical index within a message</param>
            <param name="depth">indentation level</param>
            <returns>field description</returns>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.ComposeIndentText(System.Int32)">
            <summary>
            Returns a string for each indentation step.
            </summary>
            <param name="indent">number of spaces to indent at each step</param>
            <returns>indentation string</returns>
        </member>
        <member name="M:Fudge.FudgeMsgFormatter.GetTypeName(Fudge.FudgeFieldType)">
            <summary>
            Gets the .NET name of a <c>FudgeFieldType</c> object.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="P:Fudge.FudgeMsgFormatter.Writer">
            <summary>
            Gets the target for text output.
            </summary>
        </member>
        <member name="P:Fudge.FudgeMsgFormatter.Indent">
            <summary>
            Gets the indent width (number of spaces)
            </summary>
        </member>
        <member name="T:Fudge.FudgeTypeDictionary">
            <summary>
            Contains all the <see cref="T:Fudge.FudgeFieldType"/> definitions for a particular
            Fudge installation.
            You control it through your <see cref="T:Fudge.FudgeContext"/>.
            </summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.INDICATOR_TYPE_ID">
            <summary>Predefined constant for IndicatorType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BOOLEAN_TYPE_ID">
            <summary>Predefined constant for PrimitiveFieldTypes.BooleanType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.SBYTE_TYPE_ID">
            <summary>Predefined constant for PrimitiveFieldTypes.SByteType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.SHORT_TYPE_ID">
            <summary>Predefined constant for PrimitiveFieldTypes.ShortType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.INT_TYPE_ID">
            <summary>Predefined constant for PrimitiveFieldTypes.IntType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.LONG_TYPE_ID">
            <summary>Predefined constant for PrimitiveFieldTypes.LongType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARRAY_TYPE_ID">
            <summary>Predefined constant for ByteArrayFieldType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.SHORT_ARRAY_TYPE_ID">
            <summary>Predefined constant for ShortArrayFieldType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.INT_ARRAY_TYPE_ID">
            <summary>Predefined constant for IntArrayFieldType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.LONG_ARRAY_TYPE_ID">
            <summary>Predefined constant for LongArrayFieldType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.FLOAT_TYPE_ID">
            <summary>Predefined constant for PrimitiveFieldTypes.FloatType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.DOUBLE_TYPE_ID">
            <summary>Predefined constant for PrimitiveFieldTypes.DoubleType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.FLOAT_ARRAY_TYPE_ID">
            <summary>Predefined constant for FloatArrayFieldType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.DOUBLE_ARRAY_TYPE_ID">
            <summary>Predefined constant for DoubleArrayFieldType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.STRING_TYPE_ID">
            <summary>Predefined constant for StringFieldType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.FUDGE_MSG_TYPE_ID">
            <summary>Predefined constant for FudgeMsgFieldType - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_4_TYPE_ID">
            <summary>Predefined constant for a 4-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_8_TYPE_ID">
            <summary>Predefined constant for a 8-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_16_TYPE_ID">
            <summary>Predefined constant for a 16-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_20_TYPE_ID">
            <summary>Predefined constant for a 20-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_32_TYPE_ID">
            <summary>Predefined constant for a 32-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_64_TYPE_ID">
            <summary>Predefined constant for a 64-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_128_TYPE_ID">
            <summary>Predefined constant for a 128-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_256_TYPE_ID">
            <summary>Predefined constant for a 256-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.BYTE_ARR_512_TYPE_ID">
            <summary>Predefined constant for a 512-byte array - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.DATE_TYPE_ID">
            <summary>Predefined constant for a pure date - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.TIME_TYPE_ID">
            <summary>Predefined constant for a pure time - refer to the Fudge encoding specification.</summary>
        </member>
        <member name="F:Fudge.FudgeTypeDictionary.DATETIME_TYPE_ID">
            <summary>Predefined constant for date and time- refer to the Fudge encoding specification.</summary>
        </member>
        <member name="M:Fudge.FudgeTypeDictionary.#ctor">
            <summary>
            Creates a new dictionary with the default Fudge types. After construction custom types can be registered using <c>AddType</c>.
            </summary>
        </member>
        <member name="M:Fudge.FudgeTypeDictionary.AddType(Fudge.FudgeFieldType,System.Type[])">
            <summary>
            Registers a type definition with this dictionary. Additional .NET types can be passed that will be translated to the
            type referenced in the type definition. If a type with same numeric type identifier is already in the dictionary it
            will be replaced.
            </summary>
            <param name="type">type definition</param>
            <param name="alternativeTypes">alternative .NET types that map to this type</param>
        </member>
        <member name="M:Fudge.FudgeTypeDictionary.GetByCSharpType(System.Type)">
            <summary>
            Returns the type definition most appropiate for a value type.
            </summary>
            <param name="csharpType">type of a value</param>
            <returns>type definition</returns>
        </member>
        <member name="M:Fudge.FudgeTypeDictionary.GetByTypeId(System.Int32)">
            <summary>
            Obtain a <em>known</em> type by the type ID specified.
            For processing unhandled variable-width field types, this method will return
            <c>null</c>, and <see cref="M:Fudge.FudgeTypeDictionary.GetUnknownType(System.Int32)"/> should be used if unhandled-type
            processing is desired.        /// </summary>
        </member>
        <member name="M:Fudge.FudgeTypeDictionary.GetUnknownType(System.Int32)">
            <summary>
            Returns a type definition for a type ID not defined within this dictionary. This can be used
            to allow the message to be partially processed, preserving the unknown aspects of it.
            </summary>
            <param name="typeId">type ID</param>
            <returns>type definition</returns>
        </member>
        <member name="T:Fudge.Linq.ExpressionTreeStructureHasher">
            <summary>
            ExpressionTreeStructureHasher computes a fast hash code based on the structure of the tree, ignoring any constant values, method names, etc.
            </summary>
        </member>
        <member name="M:Fudge.Linq.ExpressionTreeStructureHasher.#ctor(System.Linq.Expressions.Expression)">
            <summary>
            Constructor.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fudge.Linq.ExpressionTreeStructureHasher.ComputeHash">
            <summary>
            Computes the hash of the expression tree.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fudge.Linq.ExpressionTreeStructureHasher.ComputeHash(System.Linq.Expressions.Expression)">
            <summary>
            Computes the hash of a supplied expression tree.
            </summary>
            <param name="e"></param>
            <returns>Tree to calculate the hash for.</returns>
        </member>
        <member name="M:Fudge.Linq.ExpressionTreeStructureHasher.Visit(System.Linq.Expressions.Expression)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Linq.FudgeExpressionTranslator">
            <summary>
            Used to translate <see cref="T:System.Linq.Expressions.Expression"/>s so that calls to get values from members of the
            reference type become <c>GetValue</c> calls on the <see cref="T:Fudge.IFudgeFieldContainer"/> instead.
            </summary>
        </member>
        <member name="T:Fudge.Linq.FudgeLinqExtensions">
            <summary>
            Extensions methods for handling Fudge messages with Linq.
            </summary>
        </member>
        <member name="M:Fudge.Linq.FudgeLinqExtensions.AsQueryable``1(System.Collections.Generic.IEnumerable{Fudge.FudgeMsg})">
            <summary>
            Map an <c>IEnumerable&lt;FudgeMsg&gt;</c> onto an <see cref="T:System.Linq.IQueryable`1"/> so
            that all the Linq compiler magic works.
            </summary>
            <typeparam name="T">Type of the object which has the structure of the message data.</typeparam>
            <param name="msgSource">Enumerable (array, list, etc.) to map</param>
            <returns></returns>
            <remarks>
            <para>In the same way as Linq-to-SQL, Linq-to-Fudge relies on there being a proper type that the message
            can be mapped onto (i.e. a property with the same name and type as each field that we need to operate
            on in the message).  This is only used to make Intellisense and the compiler work - no actual
            deserialisation into objects happens whilst processing.
            </para>
            <para>See the <c>Linq.Examples</c> unit test for some examples.</para>
            </remarks>
        </member>
        <member name="M:Fudge.Linq.FudgeLinqExtensions.AsQueryable``1(Fudge.FudgeMsg[])">
            <summary>
            Map a <c>FudgeMsg[]</c> onto an <see cref="T:System.Linq.IQueryable`1"/> so
            that all the Linq compiler magic works.
            </summary>
            <typeparam name="T">Type of the object which has the structure of the message data.</typeparam>
            <param name="msgSource">Array to map</param>
            <returns></returns>
            <remarks>
            <para>In the same way as Linq-to-SQL, Linq-to-Fudge relies on there being a proper type that the message
            can be mapped onto (i.e. a property with the same name and type as each field that we need to operate
            on in the message).  This is only used to make Intellisense and the compiler work - no actual
            deserialisation into objects happens whilst processing.
            </para>
            <para>See the <c>Linq.Examples</c> unit test for some examples.</para>
            <para>We need this version in addition to IEnumerable&lt;IFudgeFieldContainer&gt; and IEnumerable&lt;FudgeMsg&gt;
            because otherwise arrays would be ambiguous.</para>
            </remarks>
        </member>
        <member name="M:Fudge.Linq.FudgeLinqExtensions.AsQueryable``1(System.Collections.Generic.IEnumerable{Fudge.IFudgeFieldContainer})">
            <summary>
            Map an <c>IEnumerable&lt;IFudgeFieldContainer&gt;</c> onto an <see cref="T:System.Linq.IQueryable`1"/> so
            that all the Linq compiler magic works.
            </summary>
            <typeparam name="T">Type of the object which has the structure of the message data.</typeparam>
            <param name="msgSource">Enumerable (array, list, etc.) to map</param>
            <returns></returns>
            <remarks>
            <para>In the same way as Linq-to-SQL, Linq-to-Fudge relies on there being a proper type that the message
            can be mapped onto (i.e. a property with the same name and type as each field that we need to operate
            on in the message).  This is only used to make Intellisense and the compiler work - no actual
            deserialisation into objects happens whilst processing.
            </para>
            <para>See the <c>Linq.Examples</c> unit test for some examples.</para>
            </remarks>
        </member>
        <member name="T:Fudge.Linq.FudgeLinqProvider">
            <summary>
            <c>FudgeLinqProvider</c> gives an implementation of <see cref="T:System.Linq.IQueryProvider"/> for
            sequences of <see cref="T:Fudge.IFudgeFieldContainer"/>s.
            </summary>
            <remarks>
            <para>This is where the real work of Linq happens with <see cref="T:System.Linq.Expressions.Expression"/>s that
            have been built on sequences of a reference type (by the compiler) being translated
            to operate on sequences of <see cref="T:Fudge.IFudgeFieldContainer"/> instead.
            </para>
            <para>
            You would not normally construct one of these directly, but instead use the <c>AsQueryable</c>
            extension method on a <see cref="T:System.Collections.IEnumerable"/> of <see cref="T:Fudge.IFudgeFieldContainer"/>s (e.g. a <c>List</c>
            or array).
            </para>
            <para>
            Note that we only currently support Select and Where clauses - this will be extended in
            the future.
            </para>
            <para>
            For a walkthrough of how this works, have a look at Matt Warren's MSDN blog at http://blogs.msdn.com/mattwar/pages/linq-links.aspx
            on which IQToolkit is based.
            </para>
            </remarks>
        </member>
        <member name="M:Fudge.Linq.FudgeLinqProvider.#ctor(System.Collections.Generic.IEnumerable{Fudge.IFudgeFieldContainer})">
            <summary>
            Constructs a new <c>FudgeLinqProvider</c> from a set of <see cref="T:Fudge.IFudgeFieldContainer"/>s (e.g. <see cref="T:Fudge.FudgeMsg"/>s),
            using a cache to avoid recompilation of expressions we have already seen.
            </summary>
            <param name="source">Set of messages to operate on.</param>
        </member>
        <member name="M:Fudge.Linq.FudgeLinqProvider.#ctor(System.Collections.Generic.IEnumerable{Fudge.IFudgeFieldContainer},System.Boolean)">
            <summary>
            Constructs a new <c>FudgeLinqProvider</c> from a set of <see cref="T:Fudge.IFudgeFieldContainer"/>s (e.g. <see cref="T:Fudge.FudgeMsg"/>s),
            giving explicit control over whether to use a cache to avoid recompilation of expressions we have already seen.
            </summary>
            <param name="source">Set of messages to operate on.</param>
            <param name="useCache">If true then compiled expressions are cached and reused.</param>
        </member>
        <member name="M:Fudge.Linq.FudgeLinqProvider.GetQueryText(System.Linq.Expressions.Expression)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Linq.FudgeLinqProvider.Execute(System.Linq.Expressions.Expression)">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Linq.FudgeLinqProvider.Source">
            <summary>
            Gets the source of messages used by this provider.
            </summary>
        </member>
        <member name="T:Fudge.Linq.FudgeLinqProvider.ConstantExtractor">
            <summary>
            Extracts constants from the expression tree out so the compiled query can be used with
            different constants.
            </summary>
            <remarks>
            It'd be nice to use IQToolkit.QueryCache.QueryParameterizer, but that's not public
            </remarks>
        </member>
        <member name="T:Fudge.Linq.FudgeLinqProvider.ParamArrayRewriter">
            <summary>
            This turns a body that expects a number of parameters, to instead have just one array param and index into that
            </summary>
        </member>
        <member name="T:Fudge.Linq.NamespaceDoc">
            <summary>
            The <see cref="N:Fudge.Linq"/> namespace makes lists of <see cref="T:Fudge.FudgeMsg"/> objects
            available for processing in Linq expressions.
            </summary>
            <remarks>
            <para>
            In the same way as Linq-to-SQL, Linq-to-Fudge relies on there being a proper type that the message
            can be mapped onto (i.e. a property with the same name and type as each field that we need to operate
            on in the message).  This is only used to make Intellisense and the compiler work - no actual
            deserialisation into objects happens whilst processing.
            </para>
            <para>
            For more information on using Linq, see the <see cref="N:System.Linq"/> namespace documentation.
            </para>
            <para>
            Linq-to-Fudge is built upon the IQToolkit, which is available at http://www.codeplex.com/IQToolkit
            </para>
            </remarks>
            <example>
            This example shows how you use Fudge-to-Linq to be able to query a list of <see cref="T:Fudge.FudgeMsg"/> objects:
            <code>
            class Tick
            {
                // Model the data we are going to process
                public double Bid { get; set; }
                public double Ask { get; set; }
                public string Ticker { get; set; }
            }
            
            FudgeMsg CreateTickMsg(double bid, double ask, string ticker)
            {
                FudgeMsg msg = new FudgeMsg(
                                    new Field("Bid", bid),
                                    new Field("Ask", ask),
                                    new Field("Ticker", ticker));
                return msg;
            }
            
            // ...
            
            // Create some example messages
            var msgs = new FudgeMsg[] { CreateTickMsg(10.3, 11.1, "FOO"), CreateTickMsg(2.4, 3.1, "BAR") };
            
            // Query them in Linq
            var query = from tick in msgs.AsQueryable&lt;Tick&gt;()
                        where tick.Ask &gt; 4.0
                        select new { tick.Ticker, tick.Ask };
            
            // Get the results as an array so we can work with them
            var results = query.ToArray();
            </code>
            </example>
        </member>
        <member name="T:Fudge.NamespaceDoc">
             <summary>
             This is the main namespace for Fudge, containing the <c>FudgeMsg</c> and <c>FudgeContext</c> classes.  See below for an example.
             </summary>
             <example>
             The following example shows some simple operations with messages.
             <code>
             var context = new FudgeContext();
            
             // Create a message
             var msg = new FudgeMsg(new Field("name", "Eric"),
                                    new Field("age", 14),
                                    new Field("address",
                                        new Field("line1", "29 Acacia Road"),
                                        new Field("city", "London")));
            
             // Serialise it
             var stream = new MemoryStream();
             context.Serialize(msg, stream);
            
             // Get the raw bytes
             var bytes = stream.ToArray();
            
             // Deserialise it
             var msg2 = context.Deserialize(bytes).Message;
            
             // Get some data
             int age = msg2.GetInt("age") ?? 0;
             </code>
             </example>
        </member>
        <member name="T:Fudge.Serialization.ContextProperties">
            <summary>
            Context properties that affect the behaviour of the serialization framework.
            </summary>
        </member>
        <member name="F:Fudge.Serialization.ContextProperties.TypeMappingStrategyProperty">
            <summary>Property of the <see cref="T:Fudge.FudgeContext"/> that overrides the default value of <see cref="P:Fudge.Serialization.FudgeSerializer.TypeMappingStrategy"/>.</summary>
        </member>
        <member name="F:Fudge.Serialization.ContextProperties.FieldNameConventionProperty">
            <summary>Property of the <see cref="T:Fudge.FudgeContext"/> that sets the <see cref="T:Fudge.Serialization.FudgeFieldNameConvention"/> (<see cref="F:Fudge.Serialization.FudgeFieldNameConvention.Identity"/> by default).</summary>
        </member>
        <member name="F:Fudge.Serialization.ContextProperties.AllowTypeDiscoveryProperty">
            <summary>Property of the <see cref="T:Fudge.FudgeContext"/> that specifies whether types can automatically by serialized or whether they must be explicitly
            registered in the <see cref="T:Fudge.Serialization.SerializationTypeMap"/>.  By default this is <c>true</c>, i.e. types do not need explicitly registering.</summary>
        </member>
        <member name="F:Fudge.Serialization.ContextProperties.DotNetSurrogateSelectorProperty">
            <summary>Property of the <see cref="T:Fudge.FudgeContext"/> that allows a .net <see cref="T:System.Runtime.Serialization.SurrogateSelector"/> to provide surrogates for serialization that implement the
            <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> interface.</summary>
            <seealso cref="M:Fudge.Serialization.SerializationTypeMap.RegisterSurrogateSelector(System.Runtime.Serialization.ISurrogateSelector)"/>
        </member>
        <member name="T:Fudge.Serialization.DefaultTypeMappingStrategy">
            <summary>
            <c>DefaultTypeMappingStrategy</c> maps a <see cref="T:System.Type"/> onto its full name, and
            scans all loaded assemblies to try to find a type from its name.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.IFudgeTypeMappingStrategy">
            <summary>
            Implement <see cref="T:Fudge.Serialization.IFudgeTypeMappingStrategy"/> to provide a strategy for mapping types
            to the names that identify them in the serialization stream, and the reverse mapping.
            </summary>
            <remarks>
            <para>
            To specify a type mapper other than the default, either set this in <see cref="P:Fudge.Serialization.FudgeSerializer.TypeMappingStrategy"/>
            or through <see cref="M:Fudge.FudgeContext.SetProperty(Fudge.FudgeContextProperty,System.Object)"/> using <see cref="F:Fudge.Serialization.ContextProperties.TypeMappingStrategyProperty"/>.
            </para>
            <para>See <see cref="T:Fudge.Serialization.JavaTypeMappingStrategy"/> for an example.</para>
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.IFudgeTypeMappingStrategy.GetName(System.Type)">
            <summary>
            Maps a <see cref="T:System.Type"/> to a name.
            </summary>
            <param name="type">Type to map.</param>
            <returns>Name to use in serialization stream.</returns>
        </member>
        <member name="M:Fudge.Serialization.IFudgeTypeMappingStrategy.GetType(System.String)">
            <summary>
            Maps a name in a serialization stream to a <see cref="T:System.Type"/>.
            </summary>
            <param name="name">Name to map.</param>
            <returns>Corresponding <see cref="T:System.Type"/> or <c>null</c> if not found.</returns>
        </member>
        <member name="M:Fudge.Serialization.DefaultTypeMappingStrategy.GetName(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.DefaultTypeMappingStrategy.GetType(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.DefaultTypeMappingStrategy.GetCachedType(System.String,System.Boolean)">
            <summary>
            Uses <see cref="M:Fudge.Serialization.DefaultTypeMappingStrategy.FindType(System.String,System.Boolean)"/> to find a type from a name, then caches it.
            </summary>
            <param name="name">Name of type to get.</param>
            <param name="ignoreCase">If <c>true</c> then case is ignored.</param>
            <returns>Matching <see cref="T:System.Type"/>, or <c>null</c> if not found.</returns>
        </member>
        <member name="M:Fudge.Serialization.DefaultTypeMappingStrategy.GetOrAddNonNullToDictionary``2(System.Collections.Generic.Dictionary{``0,``1},System.Threading.ReaderWriterLockSlim,``0,System.Func{``0,``1})">
            <remarks>
            TODO replace with ConcurrentDictionary when we move to .NET 4
            NOTE the special null behaviour
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.DefaultTypeMappingStrategy.FindType(System.String,System.Boolean)">
            <summary>
            Performs a search of all the assemblies in the current <see cref="T:System.AppDomain"/> to find the given type.
            </summary>
            <param name="name">Name of type to find.</param>
            <param name="ignoreCase">If <c>true</c> then case is ignored when searching for types.</param>
            <returns>Type if found or <c>null</c>.</returns>
            <remarks>Derived types can override this method to change the search behaviour.</remarks>
        </member>
        <member name="T:Fudge.Serialization.FudgeFieldNameConvention">
            <summary>
            <c>FudgeFieldNameConvention</c> is used to specify a default mapping from .net property names to Fudge field names.
            </summary>
        </member>
        <member name="F:Fudge.Serialization.FudgeFieldNameConvention.Identity">
            <summary>Field name is exactly the same as the property name.</summary>
        </member>
        <member name="F:Fudge.Serialization.FudgeFieldNameConvention.CamelCase">
            <summary>Field name begins with a lower-case letter and is otherwise identical to property name - e.g. "someProperty".</summary>
        </member>
        <member name="F:Fudge.Serialization.FudgeFieldNameConvention.PascalCase">
            <summary>Field name begins with an upper-case letter and is otherwise identical to property name - e.g. "SomeProperty".</summary>
        </member>
        <member name="F:Fudge.Serialization.FudgeFieldNameConvention.AllLowerCase">
            <summary>Field name is property name converted entirely to lower case - e.g. "someproperty".</summary>
        </member>
        <member name="F:Fudge.Serialization.FudgeFieldNameConvention.AllUpperCase">
            <summary>Field name is property name converted entirely to upper case - e.g. "SOMEPROPERTY".</summary>
        </member>
        <member name="T:Fudge.Serialization.FudgeFieldNameConventionAttribute">
            <summary>
            Overrides the name of the field that a property will serialize as.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.FudgeFieldNameConventionAttribute.#ctor(Fudge.Serialization.FudgeFieldNameConvention)">
            <summary>
            Initializes a new instance of the <see cref="T:Fudge.Serialization.FudgeFieldNameConventionAttribute"/> class.
            </summary>
            <param name="convention">Field name to use for this property.</param>
        </member>
        <member name="P:Fudge.Serialization.FudgeFieldNameConventionAttribute.Convention">
            <summary>
            Gets or sets the <see cref="T:Fudge.Serialization.FudgeFieldNameConvention"/> to use for properties of this type.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.FudgeFieldNameAttribute">
            <summary>
            Overrides the name of the field that a property will serialize as.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.FudgeFieldNameAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Fudge.Serialization.FudgeFieldNameAttribute"/> class.
            </summary>
            <param name="name">Field name to use for this property.</param>
        </member>
        <member name="P:Fudge.Serialization.FudgeFieldNameAttribute.Name">
            <summary>
            Gets or sets the field name to use for this property.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.FudgeInlineAttribute">
            <summary>
            Specifies whether an object is serialized in-line within its parent or referenced.
            </summary>
            <remarks>
            On a class, this controls the default behaviour for that class, and will override the default.  On a
            property, this will override the behaviour for the property type, just for that property.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.FudgeInlineAttribute.#ctor">
            <summary>
            Initializes a new instance of this class, defaulting <see cref="P:Fudge.Serialization.FudgeInlineAttribute.Inline"/> to be <c>true</c>.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.FudgeInlineAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of this class.
            </summary>
            <param name="inline">If <c>true</c> then the object will be serialized in-line in its parent rather than as a reference.</param>
        </member>
        <member name="P:Fudge.Serialization.FudgeInlineAttribute.Inline">
            <summary>
            Gets and sets whether the object will be serialized in-line in its parent rather than as a reference.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.FudgeSerializationExtensions">
            <summary>
            Extension methods to simplify serialization code
            </summary>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializationExtensions.WriteInline(Fudge.Serialization.IFudgeSerializer,Fudge.IAppendingFudgeFieldContainer,System.String,System.Object)">
            <summary>
            Serializes an object as an in-line submessage field with a given name.
            </summary>
            <param name="serializer">Serializer to write the field.</param>
            <param name="msg">Parent message for the sub-message.</param>
            <param name="name">Name of field.</param>
            <param name="value">Object to serialize.</param>
            <remarks>
            By serializing the object as a sub-value, it will be written multiple times if referenced
            multple times in the object graph, it cannot be part of a cycle of references, and it does
            not support polymorphism.  If you need any of these features then use the normal
            <see cref="M:Fudge.IAppendingFudgeFieldContainer.Add(System.String,System.Object)"/> method.
            instead.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializationExtensions.WriteAllInline``1(Fudge.Serialization.IFudgeSerializer,Fudge.IAppendingFudgeFieldContainer,System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Serializes all the values as a sequence of submessages with the same field name.
            </summary>
            <typeparam name="T">Type of objects.</typeparam>
            <param name="serializer">Serializer to write the fields.</param>
            <param name="msg">Parent message for the sub-message.</param>
            <param name="name">Name of the fields.</param>
            <param name="objects">Objects to serialize.</param>
            <remarks>See the remarks in <see cref="M:Fudge.Serialization.FudgeSerializationExtensions.WriteInline(Fudge.Serialization.IFudgeSerializer,Fudge.IAppendingFudgeFieldContainer,System.String,System.Object)"/> regarding the limitations of writing as an in-line sub-message.</remarks>
            <remarks><c>null</c>s in the sequence are written as Fudge <see cref="T:Fudge.Types.IndicatorType"/>s.</remarks>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializationExtensions.WriteAllInline``1(Fudge.Serialization.IFudgeSerializer,Fudge.IAppendingFudgeFieldContainer,System.String,System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Serializes all the values as a sequence of submessages with the same field name and ordinal.
            </summary>
            <typeparam name="T">Type of objects.</typeparam>
            <param name="serializer">Serializer to write the fields.</param>
            <param name="msg">Parent message for the sub-message.</param>
            <param name="name">Name of the fields.</param>
            <param name="ordinal">Ordinal of the fields (may be <c>null</c>).</param>
            <param name="objects">Objects to serialize.</param>
            <remarks>See the remarks in <see cref="M:Fudge.Serialization.FudgeSerializationExtensions.WriteInline(Fudge.Serialization.IFudgeSerializer,Fudge.IAppendingFudgeFieldContainer,System.String,System.Object)"/> regarding the limitations of writing as an in-line sub-message.</remarks>
            <remarks><c>null</c>s in the sequence are written as Fudge <see cref="T:Fudge.Types.IndicatorType"/>s.</remarks>
        </member>
        <member name="T:Fudge.Serialization.FudgeSerializer">
            <summary>
            The main entry-point for performing serialization and deserialization of .net objects with Fudge.
            </summary>
            <remarks>
            For exmaples and more information on the serialization capabilities of the Fudge serialization framework,
            please see the <see cref="N:Fudge.Serialization"/> namespace documentation.
            </remarks>
        </member>
        <member name="F:Fudge.Serialization.FudgeSerializer.TypeIdFieldOrdinal">
            <summary>Constant defining the ordinal for the field in which type information is stored.</summary>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializer.#ctor(Fudge.FudgeContext)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.FudgeSerializer"/> instance.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> for the serializer.</param>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializer.#ctor(Fudge.FudgeContext,Fudge.Serialization.SerializationTypeMap)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.FudgeSerializer"/> instance.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> for the serializer.</param>
            <param name="typeMap">Typemap to use rather than creating a default one.</param>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializer.Serialize(Fudge.IFudgeStreamWriter,System.Object)">
            <summary>
            Serializes an object graph to a Fudge message stream.
            </summary>
            <param name="writer">Stream to write the messages to.</param>
            <param name="graph">Starting point for graph of objects to serialize.</param>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializer.SerializeToMsg(System.Object)">
            <summary>
            Convenience method to serializae an object graph to a list of <see cref="T:Fudge.FudgeMsg"/> objects.
            </summary>
            <param name="graph">Starting point for graph of objects to serialize.</param>
            <returns>List of FudgeMsg objects containing the serialized state.</returns>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializer.Deserialize(Fudge.IFudgeStreamReader)">
            <summary>
            Deserializes an object graph from a message stream.
            </summary>
            <param name="reader">Reader to get messages from the underlying stream.</param>
            <returns>Deserialized object graph.</returns>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializer.Deserialize``1(Fudge.IFudgeStreamReader)">
            <summary>
            Deserializes an object graph from a message stream.
            </summary>
            <param name="reader">Reader to get messages from the underlying stream.</param>
            <typeparam name="T">The type to use if not specified in the metadata.</typeparam>
            <returns>Deserialized object graph.</returns>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializer.Deserialize(Fudge.FudgeMsg,System.Type)">
            <summary>
            Convenience method to deserialize an object graph from a message.
            </summary>
            <param name="msg">Message containing serialized state.</param>
            <param name="hintType">The type to use if not specified in the metadata.</param>
            <returns>Deserialized object graph.</returns>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializer.Deserialize``1(Fudge.FudgeMsg)">
            <summary>
            Convenience method to deserialize an object graph from a message.
            </summary>
            <param name="msg">Message containing serialized state.</param>
            <typeparam name="T">The type to use if not specified in the metadata.</typeparam>
            <returns>Deserialized object graph.</returns>
        </member>
        <member name="P:Fudge.Serialization.FudgeSerializer.TypeMappingStrategy">
            <summary>
            Gets and sets the strategy to use for mapping .net types to and from
            </summary>
        </member>
        <member name="P:Fudge.Serialization.FudgeSerializer.TypeMap">
            <summary>
            Gets the <see cref="T:Fudge.Serialization.SerializationTypeMap"/> used by this serializer.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.FudgeSurrogateAttribute">
            <summary>
            Specifies a surrogate class that is used to perform the serialization/deserialization for this class.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.FudgeSurrogateAttribute.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Fudge.Serialization.FudgeSurrogateAttribute"/> class.
            </summary>
            <param name="surrogateType">Surrogate type to serialize/deserialize this class.</param>
        </member>
        <member name="P:Fudge.Serialization.FudgeSurrogateAttribute.SurrogateType">
            <summary>
            Gets and sets the surrogate type to serialize/deserialize the class.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.FudgeTransientAttribute">
            <summary>
            Marks a property as not requiring serialization
            </summary>
        </member>
        <member name="T:Fudge.Serialization.IFudgeSerializable">
             <summary>
             Implement <c>IFudgeSerializable</c> to allow your class to serialize and deserialize to
             Fudge message streams.
             </summary>
             <example>
             This example shows a class implementing <see cref="T:Fudge.Serialization.IFudgeSerializable"/> directly:
             <code>
             public class Person : IFudgeSerializable
             {
                 public string Name { get; set; }
                 public Address MainAddress { get; set; }
            
                 public Person()
                 {
                 }
            
                 #region IFudgeSerializable Members
            
                 public virtual void Serialize(IAppendingFudgeFieldContainer msg, IFudgeSerializer serializer)
                 {
                     msg.Add("name", Name);
                     msg.AddIfNotNull("mainAddress", MainAddress);
                 }
            
                 public virtual void Deserialize(IFudgeFieldContainer msg, IFudgeDeserializer deserializer)
                 {
                     foreach (IFudgeField field in msg)
                     {
                         DeserializeField(deserializer, field);
                     }
                 }
            
                 #endregion
            
                 protected virtual bool DeserializeField(IFudgeDeserializer deserializer, IFudgeField field)
                 {
                     switch (field.Name)
                     {
                         case "name":
                             Name = field.GetString();
                             return true;
                         case "mainAddress":
                             MainAddress = deserializer.FromField&lt;Address&gt;(field);
                             return true;
                     }
            
                     // Field not recognised
                     return false;
                 }
             }
             </code>
             The code for the <c>Address</c> class is not shown here, but it could similarly implement <see cref="T:Fudge.Serialization.IFudgeSerializable"/> or alternatively
             use one of the other approaches to serialization - see the <see cref="N:Fudge.Serialization"/> namespace for more info.
             </example>
        </member>
        <member name="M:Fudge.Serialization.IFudgeSerializable.Serialize(Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <summary>
            Serializes the object into a message.
            </summary>
            <param name="msg">Message to serialize the object into.</param>
            <param name="serializer">Serializer to receive the data.</param>
        </member>
        <member name="M:Fudge.Serialization.IFudgeSerializable.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <summary>
            Deserializes a message into the object.
            </summary>
            <param name="msg">Message containing the data.</param>
            <param name="deserializer">Deserializer providing the data.</param>
        </member>
        <member name="T:Fudge.Serialization.IFudgeSerializer">
            <summary>
            <c>IFudgeSerializer</c> is the interface through which objects (or their surrogates)
            write data during serialization.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.IFudgeSerializer.WriteInline(Fudge.IAppendingFudgeFieldContainer,System.String,System.Nullable{System.Int32},System.Object)">
            <summary>
            Writes a child object as a serialized sub-message with a given name and/or ordinal.
            </summary>
            <param name="msg">Parent message for the sub-message.</param>
            <param name="fieldName">Name of field, may be <c>null</c>.</param>
            <param name="ordinal">Ordinal of field, may be <c>null</c>.</param>
            <param name="obj">Child object to write.</param>
            <remarks>If <c>obj</c> is <c>null</c> then the sub-message will be omitted.</remarks>
        </member>
        <member name="P:Fudge.Serialization.IFudgeSerializer.Context">
            <summary>
            Gets the <see cref="T:Fudge.FudgeContext"/> for this deserializer.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.FudgeSerializationContext">
            <summary>
            Provides an implementation of <see cref="T:Fudge.Serialization.IFudgeSerializer"/> used by the <see cref="T:Fudge.Serialization.FudgeSerializer"/>.
            </summary>
            <remarks>
            You should not need to use this class directly.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.FudgeSerializationContext.WriteInline(Fudge.IAppendingFudgeFieldContainer,System.String,System.Nullable{System.Int32},System.Object)">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Serialization.FudgeSerializationContext.Context">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Serialization.FudgeSerializationContext.StreamingMessage">
            <summary>
            StreamingMessage appears to the user like it is a normal message, but rather than adding
            fields it's actually streaming them out to the writer.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.FudgeSerializationContext.IndexedStack`1">
            <summary>
            You can't index into Stack{T} so this gives us something that we can index but looks like a stack
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Fudge.Serialization.JavaTypeMappingStrategy">
            <summary>
            Provides a mapping from .net types to their equivalent Java class names.
            </summary>
            <remarks>
            <para>
            To specify a type mapper other than the default, either set this in <see cref="P:Fudge.Serialization.FudgeSerializer.TypeMappingStrategy"/>
            or through <see cref="M:Fudge.FudgeContext.SetProperty(Fudge.FudgeContextProperty,System.Object)"/> using <see cref="F:Fudge.Serialization.ContextProperties.TypeMappingStrategyProperty"/>.
            </para>
            <para>
            The following rules are used:
            <list type="bullet">
            <item><description>Java package names are lower case</description></item>
            <item><description>The initial portion of a Java package name and a .net namespace may be different</description></item>
            <item><description>Nested classes are demarked with <c>$</c> in Java but <c>+</c> in .net</description></item>
            </list>
            </para>
            </remarks>
            <example>
            This example shows a <see cref="T:Fudge.Serialization.JavaTypeMappingStrategy"/> being constructed that maps between the
            <c>Fudge</c> .net namespace and the <c>org.fudgemsg</c> Java package, and registering it as the
            default to use for all <see cref="T:Fudge.Serialization.FudgeSerializer"/>s created from the context:
            <code>
            var context = new FudgeContext();
            var mapper = new JavaTypeMappingStrategy("Fudge.Tests.Unit", "org.fudgemsg");
            context.SetProperty(ContextProperties.TypeMappingStrategyProperty, mapper);
            </code>
            </example>
        </member>
        <member name="M:Fudge.Serialization.JavaTypeMappingStrategy.#ctor">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.JavaTypeMappingStrategy"/> where the .net namespace maps directly onto the Java package.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.JavaTypeMappingStrategy.#ctor(System.String,System.String)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.JavaTypeMappingStrategy"/>, mapping between a given .net namespace prefix and Java package prefix.
            </summary>
            <param name="dotNetPrefix">Initial portion of .net namespace that needs to be swapped with the Java equivalent.</param>
            <param name="javaPrefix">Initial portion of Java package name that needs to be swapped with the .net equivalent.</param>
        </member>
        <member name="M:Fudge.Serialization.JavaTypeMappingStrategy.GetName(System.Type)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.JavaTypeMappingStrategy.GetType(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Serialization.NamespaceDoc">
            <summary>
            The <c>Fudge.Serialization</c> namespace contains classes and interfaces to enable serialization
            to a Fudge message stream and deserialization again from it.
            </summary>
            <remarks>
            <para>
            The <see cref="T:Fudge.Serialization.FudgeSerializer"/> can serialize to any kind stream supported by an <see cref="T:Fudge.IFudgeStreamReader"/> and
            <see cref="T:Fudge.IFudgeStreamWriter"/>, such as Fudge binary encoding, XML, or a sequence of
            <see cref="T:Fudge.FudgeMsg"/> objects.  See the <see cref="N:Fudge.Encodings"/> namespace for the
            full list of supported formats.
            </para>
            <para>
            Serialization of a class can be done in a number of ways:
            <list type="table">
            <item>
            <term>Bean-style</term>
            <description>If the class has properties with <c>get</c> and <c>set</c> for each, then the Fudge serialization framework will automatically
            generate a <see cref="T:Fudge.Serialization.Reflection.PropertyBasedSerializationSurrogate"/> to handle it.</description>
            </item>
            <item>
            <term>Immutable</term>
            <description>If the class has public getters but no setters, and a constructor with arguments that match the properties (ignoring case), then
            a <see cref="T:Fudge.Serialization.Reflection.ImmutableSurrogate"/> will automatically be generated.</description>
            </item>
            <item>
            <term>Direct</term>
            <description>The class can implement <see cref="T:Fudge.Serialization.IFudgeSerializable"/> and handle its own serialization and deserialization.  This requires it to have
            a default constructor.</description>
            </item>
            <item>
            <term>
            Surrogate
            </term>
            <description>Serialization can be implemented in a separate surrogate class which implements <see cref="T:Fudge.Serialization.IFudgeSerializationSurrogate"/> to perform the
            serialization and deserialization.  This can  be specified either through the <see cref="T:Fudge.Serialization.FudgeSurrogateAttribute"/> attribute on the class, or by
            explicitly registering the surrogate with the <see cref="P:Fudge.Serialization.FudgeSerializer.TypeMap"/>.</description>
            </item>
            <item>
            <term>Convention</term>
            <description>If the class implements <c>public void ToFudgeMsg(IAppendingFudgeFieldContainer msg, IFudgeSerializer serializer)</c> and
            <c>public static &lt;YourType&gt; FromFudgeMsg(IFudgeFieldContainer msg, IFudgeDeserializer deserializer)</c> then these will be used
            to serialize and deserialize.</description>
            </item>
            <item>
            <term>[DataContract]</term>
            <description>Classes written for WCF and marked with <see cref="T:System.Runtime.Serialization.DataContractAttribute"/> will be serialized with <see cref="T:System.Runtime.Serialization.DataContractSerializer"/>
            logic.  In particular, only members and properties marked with <see cref="T:System.Runtime.Serialization.DataMemberAttribute"/> will be serialized, and constructors will not
            be called on deserialization.  Methods marked with <see cref="T:System.Runtime.Serialization.OnSerializingAttribute"/>, <see cref="T:System.Runtime.Serialization.OnSerializedAttribute"/>,
            <see cref="T:System.Runtime.Serialization.OnDeserializingAttribute"/> and <see cref="T:System.Runtime.Serialization.OnDeserializedAttribute"/> will be called as normal.</description>
            </item>
            <item>
            <term>ISerializable</term>
            <description>Classes that have been written for the original .net serialization framework and use <see cref="T:System.Runtime.Serialization.ISerializable"/> to perform custom
            serialization may be used directly.  This is lower performance than using <see cref="T:Fudge.Serialization.IFudgeSerializable"/> because data must be marshalled via
            a <see cref="T:System.Runtime.Serialization.SerializationInfo"/>.  Also note the issues with <c>null</c> described in <see cref="T:Fudge.Serialization.Reflection.DotNetSerializableSurrogate"/>.</description>
            </item>
            <item>
            <term>ISerializationSurrogate</term>
            <description>Classes written for the original .net serialization framework and using an <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> are also supported with
            the same notes as for ISerializable above.  The <see cref="T:System.Runtime.Serialization.SurrogateSelector"/> is registered in the <see cref="T:Fudge.Serialization.SerializationTypeMap"/> or through
            the <see cref="F:Fudge.Serialization.ContextProperties.DotNetSurrogateSelectorProperty"/> context property.</description>
            </item>
            <item>
            <term>[Serializable]</term>
            <description>If a class is marked with <see cref="T:System.SerializableAttribute"/> but does not implement <see cref="T:System.Runtime.Serialization.ISerializable"/> and is not supported
            by a registered <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> then all its fields that are not marked by <see cref="T:System.NonSerializedAttribute"/> will
            be serialized and deserialized in the same way as with a <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.</description>
            </item>
            </list>
            </para>
            <para>
            To support the different naming conventions of other languages that you may be interoperating with, Fudge serialization allows you
            to modify the conventions for naming types and naming fields through the <see cref="F:Fudge.Serialization.ContextProperties.TypeMappingStrategyProperty"/>
            and <see cref="F:Fudge.Serialization.ContextProperties.FieldNameConventionProperty"/> context properties.  These would allow you for example to match
            Java conventions by converting <c>Fudge.Serialization.FudgeSerializer</c> to <c>org.fudgemsg.serialization.FudgeSerializer</c>
            and make fields by default <c>camelCase</c> rather than <c>PascalCase</c> - this is implemented by the
            <see cref="T:Fudge.Serialization.JavaTypeMappingStrategy"/> class.
            </para>
            <para>
            When using runtime-generated surrogates, serialization of fields can further be controlled through the use of the
            <see cref="T:Fudge.Serialization.FudgeTransientAttribute"/> and <see cref="T:Fudge.Serialization.FudgeFieldNameAttribute"/> attributes.
            </para>
            </remarks>
            <example>
            The following example shows how to serialize an object to a Fudge-encoded binary stream:
            <code>
            // Create a context and a serializer
            var context = new FudgeContext();
            var serializer = new FudgeSerializer(context);
            
            // Our object to serialize
            var temperatureRange = new TemperatureRange { High = 28.3, Low = 13.2, Average = 19.6 };
            
            // Serialize it to a MemoryStream
            var stream = new MemoryStream();
            var streamWriter = new FudgeEncodedStreamWriter(context, stream);
            serializer.Serialize(streamWriter, temperatureRange);
            
            // Reset the stream and deserialize a new object from it
            stream.Position = 0;
            var streamReader = new FudgeEncodedStreamReader(context, stream);
            var range2 = (TemperatureRange)serializer.Deserialize(streamReader);
            
            // Just check a value matches
            Debug.Assert(range2.Average == 19.6);
            </code>
            </example>
        </member>
        <member name="T:Fudge.Serialization.Reflection.ArraySurrogate">
            <summary>
            Handles serialization and deserialization of arrays.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.Reflection.CollectionSurrogateBase">
            <summary>
            Base class for surrogates handling standard collection types.
            </summary>
        </member>
        <member name="F:Fudge.Serialization.Reflection.CollectionSurrogateBase.context">
            <summary>The <see cref="T:Fudge.FudgeContext"/> used by the surrogate.</summary>
        </member>
        <member name="F:Fudge.Serialization.Reflection.CollectionSurrogateBase.typeData">
            <summary>The <see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type this surrogate serializes.</summary>
        </member>
        <member name="F:Fudge.Serialization.Reflection.CollectionSurrogateBase.serializerDelegate">
            <summary>The delegate to perform the serialization of this type.</summary>
        </member>
        <member name="F:Fudge.Serialization.Reflection.CollectionSurrogateBase.deserializerDelegate">
            <summary>The delegate to perform the deserialization of this type.</summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.CollectionSurrogateBase.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData,System.String,System.String)">
            <summary>
            Constructs a new instance.
            </summary>
            <param name="context"></param>
            <param name="typeData"></param>
            <param name="serializeMethodName">Name of method to use to serialize objects.</param>
            <param name="deserializeMethodName">Name of method to use to deserialize objects.</param>
            <remarks>
            The <see cref="T:Fudge.Serialization.Reflection.CollectionSurrogateBase"/> will scan for generic methods with the right names, and specialise them for
            the types given within <see cref="F:Fudge.Serialization.Reflection.CollectionSurrogateBase.typeData"/>.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.Reflection.CollectionSurrogateBase.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.CollectionSurrogateBase.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.CollectionSurrogateBase.SerializeList``1(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <summary>
            Helper method to serialize list contents.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="msg"></param>
            <param name="serializer"></param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.CollectionSurrogateBase.SerializeList``1(System.Collections.Generic.IEnumerable{``0},Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer,Fudge.Serialization.Reflection.TypeData.TypeKind,System.Nullable{System.Int32})">
            <summary>
            Helper method to serialize list contents.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="msg"></param>
            <param name="serializer"></param>
            <param name="kind"></param>
            <param name="ordinal"></param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.CollectionSurrogateBase.DeserializeField``1(Fudge.IFudgeField,Fudge.Serialization.IFudgeDeserializer,Fudge.Serialization.Reflection.TypeData.TypeKind)">
            <summary>
            Helper method to deserialize an individual field.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="field"></param>
            <param name="deserializer"></param>
            <param name="kind"></param>
            <returns></returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ArraySurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new instance for a specific array type
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> for this surrogate.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> describing the type to serialize.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ArraySurrogate.CanHandle(Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Detects whether a given type can be serialized with this class.
            </summary>
            <param name="type">Type to test.</param>
            <returns><c>true</c> if this class can handle the type.</returns>
        </member>
        <member name="T:Fudge.Serialization.Reflection.DictionarySurrogate">
            <summary>
            Handles serialization and deserialization of generic dictionaries.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DictionarySurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new instance for a specific dictionary type
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> for this surrogate.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> describing the type to serialize.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DictionarySurrogate.CanHandle(Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Detects whether a given type can be serialized with this class.
            </summary>
            <param name="typeData">Type to test.</param>
            <returns><c>true</c> if this class can handle the type.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DictionarySurrogate.IsDictionary(System.Type)">
            <summary>
            Detects whether a given type is a generic dictionary.
            </summary>
            <param name="type">Type to test.</param>
            <returns><c>true</c> if the type is a dictionary.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.DictionarySurrogate.IsDictionary(System.Type,System.Type@,System.Type@)">
            <summary>
            Detects whether a given type is a generic dictionary and obtains the key and value types.
            </summary>
            <param name="type">Type to test.</param>
            <param name="keyType">Returns the type of the keys.</param>
            <param name="valueType">Returns the type of the values.</param>
            <returns><c>true</c> if the type is a dictionary.</returns>
        </member>
        <member name="T:Fudge.Serialization.Reflection.ListSurrogate">
            <summary>
            Handles serialization and deserialization of generic lists.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ListSurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new instance for a specific list type
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> for this surrogate.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> describing the type to serialize.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ListSurrogate.CanHandle(Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Detects whether a given type can be serialized with this class.
            </summary>
            <param name="typeData">Type to test.</param>
            <returns><c>true</c> if this class can handle the type.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ListSurrogate.IsList(System.Type)">
            <summary>
            Detects whether a given type is a generic list.
            </summary>
            <param name="type">Type to test.</param>
            <returns><c>true</c> if the type is a list.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ListSurrogate.IsList(System.Type,System.Type@)">
            <summary>
            Detects whether a given type is a generic dictionary and obtains the element type.
            </summary>
            <param name="type">Type to test.</param>
            <param name="elementType">Returns the type of the elements.</param>
            <returns><c>true</c> if the type is a list.</returns>
        </member>
        <member name="T:Fudge.Serialization.Reflection.NamespaceDoc">
            <summary>
            <para>
            The <c>Fudge.Serialization.Reflection</c> namespace contains helper classes that are used
            to automatically create surrogates for types rather than needing explicit implementations.
            </para>
            You would not normally use classes in this namespace directly - the framework will use them
            if you have set the <see cref="F:Fudge.Serialization.ContextProperties.AllowTypeDiscoveryProperty"/> context
            property to be <c>true</c> (which is the default).
            </summary>
        </member>
        <member name="T:Fudge.Serialization.Reflection.PropertyBasedSerializationSurrogate">
            <summary>
            Used to handle classes which are bean-style (i.e. have matching getters and setters and a default constructor).
            </summary>
            <remarks>
            For lists (i.e. properties that implement <see cref="T:System.Collections.Generic.IList`1"/>, no setter is required but the object itself must construct the list
            so that values can be added to it.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.Reflection.PropertyBasedSerializationSurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.Reflection.PropertyBasedSerializationSurrogate"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type for this surrogate.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.PropertyBasedSerializationSurrogate.CanHandle(Fudge.Serialization.Reflection.TypeDataCache,Fudge.Serialization.FudgeFieldNameConvention,System.Type)">
            <summary>
            Determines whether this kind of surrogate can handle a given type
            </summary>
            <param name="cache"><see cref="T:Fudge.Serialization.Reflection.TypeDataCache"/> for type data.</param>
            <param name="fieldNameConvention">Convention to use for renaming fields.</param>
            <param name="type">Type to test.</param>
            <returns>True if this kind of surrogate can handle the type.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.PropertyBasedSerializationSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.PropertyBasedSerializationSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.PropertyBasedSerializationSurrogate.PropertySerializerMixin.CreateAndDeserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <summary>
            Creates the object without calling a constructor, registers it, and deserializes the message into it
            </summary>
            <param name="msg"></param>
            <param name="deserializer"></param>
            <returns>Deserialized object</returns>
        </member>
        <member name="T:Fudge.Serialization.Reflection.FudgeSurrogateSelector">
            <summary>
            Internal class to help choose a surrogate that is used to serialize a given type.
            </summary>
            <remarks>
            The <see cref="T:Fudge.Serialization.Reflection.FudgeSurrogateSelector"/> will automatically handle lists, dictionaries and arrays, and
            where possible create surrogates for other types (for example if they have properties with getters and
            setters, or implement <see cref="T:Fudge.Serialization.IFudgeSerializable"/>).  It also follows the
            <see cref="T:Fudge.Serialization.FudgeSurrogateAttribute"/> attribute to specify another class that is the surrogate for the
            given type.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.Reflection.FudgeSurrogateSelector.#ctor(Fudge.FudgeContext)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.Reflection.FudgeSurrogateSelector"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> for this selector.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.FudgeSurrogateSelector.GetSurrogate(System.Type,Fudge.Serialization.FudgeFieldNameConvention)">
            <summary>
            Creates a surrogate for a given type.
            </summary>
            <param name="type">Type for which to get surrogate.</param>
            <param name="fieldNameConvention">Convention for mapping .net property names to serialized field names.</param>
            <returns>Surrogate for the type.</returns>
            <exception cref="T:Fudge.FudgeRuntimeException">Thrown if no surrogate can be automatically created.</exception>
        </member>
        <member name="P:Fudge.Serialization.Reflection.FudgeSurrogateSelector.DotNetSurrogateSelector">
            <summary>
            Gets or sets an <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> which provides surrogates implementing
            <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> to allow old code to use Fudge serialization.
            </summary>
        </member>
        <member name="T:Fudge.Serialization.Reflection.ToFromFudgeMsgSurrogate">
            <summary>
            A surrogate that works with classes providing <c>ToFudgeMsg</c> and static <c>FromFudgeMsg</c> methods.
            </summary>
            <remarks>
            The full signatures of the methods are <c>public void ToFudgeMsg(IAppendingFudgeFieldContainer msg, IFudgeSerializer serializer)</c> and
            <c>public static &lt;YourType&gt; FromFudgeMsg(IFudgeFieldContainer msg, IFudgeDeserializer deserializer)</c>.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ToFromFudgeMsgSurrogate.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.Reflection.ToFromFudgeMsgSurrogate"/>.
            </summary>
            <param name="context"><see cref="T:Fudge.FudgeContext"/> to use.</param>
            <param name="typeData"><see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type for this surrogate.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ToFromFudgeMsgSurrogate.CanHandle(Fudge.Serialization.Reflection.TypeDataCache,Fudge.Serialization.FudgeFieldNameConvention,System.Type)">
            <summary>
            Determines whether this kind of surrogate can handle a given type
            </summary>
            <param name="cache"><see cref="T:Fudge.Serialization.Reflection.TypeDataCache"/> for type data.</param>
            <param name="fieldNameConvention">Convention to use for renaming fields.</param>
            <param name="type">Type to test.</param>
            <returns>True if this kind of surrogate can handle the type.</returns>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ToFromFudgeMsgSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.Reflection.ToFromFudgeMsgSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Serialization.Reflection.TypeData">
            <summary>
            Describes reflection-based information about a type
            </summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.TypeData.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.TypeDataCache,System.Type,Fudge.Serialization.FudgeFieldNameConvention)">
            <summary>
            Constructs a new instance
            </summary>
            <param name="context"></param>
            <param name="cache"></param>
            <param name="type"></param>
            <param name="fieldNameConvention"></param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.TypeData.GetCustomAttribute``1">
            <summary>
            Gets the first custom attribute of a given type
            </summary>
            <typeparam name="T">Type of attribute to select</typeparam>
            <returns>Matching attribute or <c>null</c>.</returns>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.Type">
            <summary>Gets the <see cref="P:Fudge.Serialization.Reflection.TypeData.Type"/> this <see cref="T:Fudge.Serialization.Reflection.TypeData"/> describes.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.DefaultConstructor">
            <summary>Gets the default constructor, if present.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.Constructors">
            <summary>Gets all the constructors for the type.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.Properties">
            <summary>Gets <see cref="T:Fudge.Serialization.Reflection.TypeData.PropertyData"/> describing the properties of the type.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.Fields">
            <summary>Gets <see cref="T:Fudge.Serialization.Reflection.TypeData.PropertyData"/> describing the fields of the type.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.CustomAttributes">
            <summary>Gets any custom attributes for the type.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.Kind">
            <summary>Gets the way that this type should be serialized by default.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.SubTypeData">
            <summary>For lists and arrays, this is the <see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type of elements in the list.  For dictionaries it's the key type</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.SubType2Data">
            <summary>For dictionaries, this is the <see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the type of the values</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.SubType">
            <summary>For lists and arrays, this is the type of elements in the list.  For dictionaries it's the key type</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.SubType2">
            <summary>For dictionaries, this is the type of the values</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.FieldType">
            <summary>Gets the <see cref="T:Fudge.FudgeFieldType"/> to store this type in.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PublicMethods">
            <summary>Gets all public instance methods of the type.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.StaticPublicMethods">
            <summary>Gets all public static methods of the type</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.AllInstanceMethods">
            <summary>Gets all instance methods of the type, no matter the visibility.</summary>
        </member>
        <member name="T:Fudge.Serialization.Reflection.TypeData.TypeKind">
            <summary>
            Enunerates the different ways a type may be serialized.
            </summary>
        </member>
        <member name="F:Fudge.Serialization.Reflection.TypeData.TypeKind.FudgePrimitive">
            <summary>Serialize as a fudge field.</summary>
        </member>
        <member name="F:Fudge.Serialization.Reflection.TypeData.TypeKind.Inline">
            <summary>Serialize as a sub-message.</summary>
        </member>
        <member name="F:Fudge.Serialization.Reflection.TypeData.TypeKind.Reference">
            <summary>Serialize as a sub-message but allow references.</summary>
        </member>
        <member name="T:Fudge.Serialization.Reflection.TypeData.PropertyData">
            <summary>
            Holds reflection-based data about a property of a type.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.TypeData.PropertyData.#ctor(Fudge.Serialization.Reflection.TypeDataCache,Fudge.Serialization.FudgeFieldNameConvention,System.Reflection.PropertyInfo)">
            <summary>
            Contructs a new instance based on a property
            </summary>
            <param name="typeCache"></param>
            <param name="fieldNameConvention"></param>
            <param name="info"></param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.TypeData.PropertyData.#ctor(Fudge.Serialization.Reflection.TypeDataCache,Fudge.Serialization.FudgeFieldNameConvention,System.Reflection.FieldInfo)">
            <summary>
            Contructs a new instance based on a field
            </summary>
            <param name="typeCache"></param>
            <param name="fieldNameConvention"></param>
            <param name="info"></param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.TypeData.PropertyData.GetCustomAttribute``1">
            <summary>
            Gets the first custom attribute of a given type
            </summary>
            <typeparam name="T">Type of attribute to get</typeparam>
            <returns>Matching attribute, or <c>null</c> if not found</returns>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PropertyData.Name">
            <summary>Gets the name of the property.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PropertyData.TypeData">
            <summary>Gets the <see cref="P:Fudge.Serialization.Reflection.TypeData.PropertyData.TypeData"/> describing the type of the property.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PropertyData.Type">
            <summary>Gets the <see cref="P:Fudge.Serialization.Reflection.TypeData.PropertyData.Type"/> of the property.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PropertyData.Kind">
            <summary>Gets the way the the property should be serialized.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PropertyData.Getter">
            <summary>Gets a delegate that calls the getter of the property</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PropertyData.Setter">
            <summary>Gets a delegate that calls the setter of the property</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PropertyData.HasPublicSetter">
            <summary>Gets whether the property has a public setter.</summary>
        </member>
        <member name="P:Fudge.Serialization.Reflection.TypeData.PropertyData.SerializedName">
            <summary>Gets the name that should be used to serialize the property after any conventions, etc. have been applied.</summary>
        </member>
        <member name="T:Fudge.Serialization.Reflection.TypeDataCache">
            <summary>
            <c>TypeDataCache</c> is used to cache <see cref="T:Fudge.Serialization.Reflection.TypeData"/> reflected from types for serialisation.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.Reflection.TypeDataCache.#ctor(Fudge.FudgeContext)">
            <summary>
            Cosntructs a new <see cref="T:Fudge.Serialization.Reflection.TypeDataCache"/>.
            </summary>
            <param name="context">Context for this cache.</param>
        </member>
        <member name="M:Fudge.Serialization.Reflection.TypeDataCache.GetTypeData(System.Type,Fudge.Serialization.FudgeFieldNameConvention)">
            <summary>
            Gets the type data for a given type, constructing if necessary.
            </summary>
            <param name="type">Type for which to get data.</param>
            <param name="fieldNameConvention">Convention for mapping .net property names to serialized field names.</param>
            <returns><see cref="T:Fudge.Serialization.Reflection.TypeData"/> for the given type.</returns>
        </member>
        <member name="T:Fudge.Serialization.SerializableSurrogate">
            <summary>
            <c>SerializableSurrogate</c> acts as a surrogate for objects that implement <see cref="T:Fudge.Serialization.IFudgeSerializable"/>.
            </summary>
            <remarks>
            You should not normally need to use this class directly.
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.SerializableSurrogate.#ctor(System.Type)">
            <summary>
            Constructs a new <c>SerializableSurrogate</c> for a given type.
            </summary>
            <param name="type">Type of the object, which must implement <see cref="T:Fudge.Serialization.IFudgeSerializable"/> and have a default constructor.</param>
        </member>
        <member name="M:Fudge.Serialization.SerializableSurrogate.CanHandle(Fudge.Serialization.Reflection.TypeData)">
            <summary>
            Detects whether a given type can be serialized with this class.
            </summary>
            <param name="typeData">Type to test.</param>
            <returns><c>true</c> if this class can handle the type.</returns>
        </member>
        <member name="M:Fudge.Serialization.SerializableSurrogate.Serialize(System.Object,Fudge.IAppendingFudgeFieldContainer,Fudge.Serialization.IFudgeSerializer)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Serialization.SerializableSurrogate.Deserialize(Fudge.IFudgeFieldContainer,Fudge.Serialization.IFudgeDeserializer)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Serialization.SerializationTypeMap">
            <summary>
            Holds the mapping of types to surrogates used to serialize or deserialize them.
            </summary>
        </member>
        <member name="M:Fudge.Serialization.SerializationTypeMap.#ctor(Fudge.FudgeContext)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.SerializationTypeMap"/>
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Fudge.Serialization.SerializationTypeMap.#ctor(Fudge.FudgeContext,Fudge.Serialization.Reflection.FudgeSurrogateSelector)">
            <summary>
            Constructs a new <see cref="T:Fudge.Serialization.SerializationTypeMap"/>
            </summary>
            <param name="context"></param>
            <param name="surrogateSelector"></param>
        </member>
        <member name="M:Fudge.Serialization.SerializationTypeMap.RegisterType(System.Type)">
            <summary>
            Registers a type, automatically generating a serialization surrogate.
            </summary>
            <param name="type">Type to register.</param>
            <returns></returns>
        </member>
        <member name="M:Fudge.Serialization.SerializationTypeMap.RegisterType(System.Type,Fudge.Serialization.IFudgeSerializationSurrogate)">
            <summary>
            Registers a type with a serialization surrogate.
            </summary>
            <param name="type">Type that the surrogate is for.</param>
            <param name="surrogate">Surrogate to serialize and deserialize the type.</param>
        </member>
        <member name="M:Fudge.Serialization.SerializationTypeMap.RegisterSurrogateSelector(System.Runtime.Serialization.ISurrogateSelector)">
            <summary>
            Registers a .net <see cref="T:System.Runtime.Serialization.ISurrogateSelector"/> which provides <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/>s to
            perform the serialization and deserialization.
            </summary>
            <param name="selector">Selector to register</param>
            <remarks>
            <para>
            This allows code that has been written with the original .net <see cref="T:System.Runtime.Serialization.ISerializationSurrogate"/> to be
            used with Fudge with little or no modification.
            </para>
            <para>
            The default selector can be set using the <see cref="F:Fudge.Serialization.ContextProperties.DotNetSurrogateSelectorProperty"/>
            context property.  Calling this will replace any previously registered selector.
            </para>
            </remarks>
        </member>
        <member name="M:Fudge.Serialization.SerializationTypeMap.GetTypeId(System.Type)">
            <summary>
            Gets an ID for a type.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks>This is used by the serialization framework and would not normally be useful to developers.</remarks>
        </member>
        <member name="M:Fudge.Serialization.SerializationTypeMap.GetSurrogate(System.Type)">
            <summary>
            Returns the surrogate for a type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Fudge.Serialization.SerializationTypeMap.GetSurrogate(System.Int32)">
            <summary>
            Gets the surrogate for a given type ID
            </summary>
            <param name="typeId"></param>
            <returns></returns>
        </member>
        <member name="P:Fudge.Serialization.SerializationTypeMap.AllowTypeDiscovery">
            <summary>
            Gets or sets whether Fudge will automatically try to register types.
            </summary>
            <remarks>
            <para>
            If this is <c>false</c>, then all types must be registered with the type map before
            serialization or deserialization.
            </para>
            <para>
            By default, this is <c>true</c>, i.e. types can be added automatically.  You can set the
            <see cref="F:Fudge.Serialization.ContextProperties.AllowTypeDiscoveryProperty"/> property in the <see cref="T:Fudge.FudgeContext"/> before
            constructing a <c>FudgeSerializer</c> to override this default, or set
            <see cref="P:Fudge.Serialization.SerializationTypeMap.AllowTypeDiscovery"/> directly.
            </para>
            </remarks>
        </member>
        <member name="P:Fudge.Serialization.SerializationTypeMap.FieldNameConvention">
            <summary>
            Gets or sets the convention to use when converting .net property names to Fudge field names, by default Identity.
            </summary>
            <remarks>
            On construction, the <see cref="T:Fudge.Serialization.SerializationTypeMap"/> will pick up any default specified
            using the <see cref="F:Fudge.Serialization.ContextProperties.FieldNameConventionProperty"/> property in the <see cref="T:Fudge.FudgeContext"/>
            of set <see cref="T:Fudge.Serialization.FudgeFieldNameConvention"/> directly.
            </remarks>
            <seealso cref="T:Fudge.Serialization.FudgeFieldNameConvention"/>
        </member>
        <member name="T:Fudge.Types.DateTimeFieldType">
            <summary>
            The type definition for a Fudge-encoded datetime
            </summary>
        </member>
        <member name="F:Fudge.Types.DateTimeFieldType.Instance">
            <summary>
            A type defintion for datetime data.
            </summary>
        </member>
        <member name="M:Fudge.Types.DateTimeFieldType.#ctor">
            <summary>
            Creates a new date field type
            </summary>
        </member>
        <member name="M:Fudge.Types.DateTimeFieldType.Minimize(System.Object,Fudge.FudgeFieldType@)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.DateTimeFieldType.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.DateTimeFieldType.WriteValue(System.IO.BinaryWriter,Fudge.Types.FudgeDateTime)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Types.FudgeArrayFieldTypeBase`1">
            <summary>
            Base class for arrays of the primitive types predefined within Fudge. This contains all of the common functionality shared by the
            array type implementations.
            </summary>
            <typeparam name="T">base .NET type</typeparam>
        </member>
        <member name="M:Fudge.Types.FudgeArrayFieldTypeBase`1.#ctor(System.Int32,System.Int32,System.Action{System.IO.BinaryWriter,`0},System.Func{System.IO.BinaryReader,`0})">
            <summary>
            Creates a new base type.
            </summary>
            <param name="typeId">Fudge type ID</param>
            <param name="elementSize">encoded size of an array element (in bytes)</param>
            <param name="writer">delegate for writing an array element</param>
            <param name="reader">delegate for reading an array element</param>
        </member>
        <member name="M:Fudge.Types.FudgeArrayFieldTypeBase`1.GetVariableSize(`0[],Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc cref="M:Fudge.FudgeFieldType.GetVariableSize(System.Object,Fudge.Taxon.IFudgeTaxonomy)"/>
        </member>
        <member name="M:Fudge.Types.FudgeArrayFieldTypeBase`1.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Types.FudgeArrayFieldTypeBase`1.WriteValue(System.IO.BinaryWriter,`0[])">
            <inheritdoc />
        </member>
        <member name="T:Fudge.Types.FudgeDate">
            <summary>
            <c>FudgeDate</c> represents a pure date in the range +-10000 years.
            </summary>
            <remarks>
            It is possible for the <c>FudgeDate</c> to represent a date that is not valid
            (e.g. 30th February), however converting to a <see cref="T:System.DateTime"/> will always
            return a valid date (rolling to the next valid day if appropriate).
            </remarks>
        </member>
        <member name="M:Fudge.Types.FudgeDate.#ctor(System.Int32)">
            <summary>
            Constructs a new <c>FudgeDate</c> based on a raw value in the form YYYYMMDD.
            </summary>
            <param name="rawValue">Value to use.</param>
            <remarks>Note that no checking is performed that the value is a valid date, so 20010230 would be accepted.</remarks>
        </member>
        <member name="M:Fudge.Types.FudgeDate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Construts a new <c>FudgeDate</c> based on a year, month and day
            </summary>
            <param name="year">Year</param>
            <param name="month">Month</param>
            <param name="day">Day</param>
        </member>
        <member name="M:Fudge.Types.FudgeDate.#ctor(System.DateTime)">
            <summary>
            Cosntructs a new <c>FudgeDate</c> from a .net <see cref="T:System.DateTime"/>.
            </summary>
            <param name="dateTime">DateTime to base this <c>FudgeDate</c> on</param>.
            <remarks>Note that timezone information is ignored, and only the date part used.</remarks>
        </member>
        <member name="M:Fudge.Types.FudgeDate.RollToValidDate">
            <summary>
            If this date does not represent a valid real date, then returns the next valid day.
            </summary>
            <returns>Valid date.</returns>
        </member>
        <member name="M:Fudge.Types.FudgeDate.IsLeap(System.Int32)">
            <summary>
            Tests whether a given year is a leap year.
            </summary>
            <param name="year">Year to test.</param>
            <returns><c>True</c> if the year is a leap year.</returns>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToDateTime">
            <summary>
            Converts this <c>FudgeDate</c> into a .net <see cref="T:System.DateTime"/>.
            </summary>
            <returns><see cref="T:System.DateTime"/> corresponding to this date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <remarks>If the <c>FudgeDate</c> does not represent a valid date, it will be rolled to the next valid date.</remarks>
        </member>
        <member name="M:Fudge.Types.FudgeDate.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToString(Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Converts the date to a string based on a given <see cref="T:Fudge.Types.FudgeDateTimePrecision"/>.
            </summary>
            <param name="precision">Precision to use.</param>
            <returns>Date as a string.</returns>
        </member>
        <member name="M:Fudge.Types.FudgeDate.CompareTo(Fudge.Types.FudgeDate)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.GetTypeCode">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToBoolean(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToByte(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToChar(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToDateTime(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToDecimal(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToDouble(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToInt16(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToInt32(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToInt64(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToSByte(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToSingle(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToType(System.Type,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToUInt16(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToUInt32(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDate.ToUInt64(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Types.FudgeDate.Year">
            <summary>
            Gets the year part of the <c>FudgeDate</c>.
            </summary>
            <remarks>
            Note that 1 AD is year 1, and 1 BC is year -1.  Year 0 is meaningless.
            </remarks>
        </member>
        <member name="P:Fudge.Types.FudgeDate.Month">
            <summary>
            Gets the month part of the <c>FudgeDate</c>, in the range 1 to 12 for valid dates.
            </summary>
        </member>
        <member name="P:Fudge.Types.FudgeDate.Day">
            <summary>
            Gets the day part of the <c>FudgeDate</c>, in the range 1 to 31 for valid dates.
            </summary>
        </member>
        <member name="P:Fudge.Types.FudgeDate.IsValid">
            <summary>
            Indicates whether the <c>FudgeDate</c> represents a real date
            </summary>
        </member>
        <member name="P:Fudge.Types.FudgeDate.RawValue">
            <summary>
            Returns the raw representation of this date.
            </summary>
        </member>
        <member name="T:Fudge.Types.DateFieldType">
            <summary>
            The type definition for a Fudge-encoded date
            </summary>
        </member>
        <member name="F:Fudge.Types.DateFieldType.Instance">
            <summary>
            A type defintion for date data.
            </summary>
        </member>
        <member name="M:Fudge.Types.DateFieldType.#ctor">
            <summary>
            Creates a new date field type
            </summary>
        </member>
        <member name="M:Fudge.Types.DateFieldType.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.DateFieldType.WriteValue(System.IO.BinaryWriter,Fudge.Types.FudgeDate)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Types.FudgeDateTime">
            <summary>
            <c>FudgeDateTime</c> represents a point in time from 9999BC to 9999AD, with up to nanosecond precision and
            optional timezone information.
            </summary>
            <remarks><c>FudgeDateTime</c> is most similar to .net's <see cref="T:System.DateTimeOffset"/> struct, but has
            better precision and range, and also allows for the offset to be optional.</remarks>
            <seealso cref="T:Fudge.Types.FudgeDate"/>
            <seealso cref="T:Fudge.Types.FudgeTime"/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.#ctor(System.DateTime)">
            <summary>
            Constructs a new <c>FudgeDateTime</c> based on a .net <see cref="T:System.DateTime"/>.
            </summary>
            <param name="dateTime"></param>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.#ctor(System.DateTime,Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Constructs a new <c>FudgeDateTime</c> based on a .net <see cref="T:System.DateTime"/>, specifying the precision.
            </summary>
            <param name="dateTime"></param>
            <param name="precision"></param>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.#ctor(System.DateTimeOffset)">
            <summary>
            Constructs a new <c>FudgeDateTime</c> based on a .net <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="dateTimeOffset"><see cref="T:System.DateTimeOffset"/> to use.</param>
            <remarks>The offset must be on a 15-minute boundary and within the +/- 30 hour range allowed by <c>FudgeDateTime</c>.</remarks>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.#ctor(System.DateTimeOffset,Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Constructs a new <c>FudgeDateTime</c> based on a .net <see cref="T:System.DateTimeOffset"/>, specifying the precision.
            </summary>
            <param name="dateTimeOffset"><see cref="T:System.DateTimeOffset"/> to use.</param>
            <param name="precision"></param>
            <remarks>The offset must be on a 15-minute boundary and within the +/- 30 hour range allowed by <c>FudgeDateTime</c>.</remarks>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Constructs a <c>FudgeDateTime</c> from component values without timezone information.
            </summary>
            <param name="year"></param>
            <param name="month"></param>
            <param name="day"></param>
            <param name="hour"></param>
            <param name="minute"></param>
            <param name="second"></param>
            <param name="nanosecond"></param>
            <param name="precision"></param>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Constructs a <c>FudgeDateTime</c> from component values with timezone information.
            </summary>
            <param name="year"></param>
            <param name="month"></param>
            <param name="day"></param>
            <param name="hour"></param>
            <param name="minute"></param>
            <param name="second"></param>
            <param name="nanosecond"></param>
            <param name="timeZoneOffset">Timezone offset from UTC, in minutes, must be multiple of 15</param>
            <param name="precision"></param>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.#ctor(Fudge.Types.FudgeDate,Fudge.Types.FudgeTime)">
            <summary>
            Constructs a new <c>FudgeDateTime</c> using a <see cref="T:Fudge.Types.FudgeDate"/> and <see cref="T:Fudge.Types.FudgeTime"/>, taking the
            precision from the <see cref="T:Fudge.Types.FudgeTime"/>.
            </summary>
            <param name="date">Date part of the datetime.</param>
            <param name="time">Time part of the datetime, may be <c>null</c>.</param>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.#ctor(Fudge.Types.FudgeDate,Fudge.Types.FudgeTime,Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Constructs a new <c>FudgeDateTime</c> using a <see cref="T:Fudge.Types.FudgeDate"/> and <see cref="T:Fudge.Types.FudgeTime"/>, specifying the precision.
            </summary>
            <param name="date">Date part of the datetime.</param>
            <param name="time">Time part of the datetime, may be <c>null</c>.</param>
            <param name="precision">Precision to use.</param>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToDateTime">
            <summary>
            Converts the <c>FudgeDateTime</c> to a .net <see cref="T:System.DateTime"/>.
            </summary>
            <returns>Equivalent .net <see cref="T:System.DateTime"/> object.</returns>
            <remarks>
            The behaviour of this method is that datetimes with an unspecified timezone are represented using
            an unspecified timezone in the <see cref="T:System.DateTime"/>.  For datetimes that contain timezone information,
            they are converted to UTC and returned as a <see cref="T:System.DateTime"/> with kind <see cref="F:System.DateTimeKind.Utc"/>.
            If you want more control over this behaviour, use <see cref="M:Fudge.Types.FudgeDateTime.ToDateTime(System.DateTimeKind,System.Boolean)"/>.
            </remarks>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToDateTime(System.DateTimeKind,System.Boolean)">
            <summary>
            Converts the <c>FudgeDateTime</c> to a .net <see cref="T:System.DateTime"/> allowing some control over timezone handling.
            </summary>
            <param name="kind"><see cref="T:System.DateTimeKind"/> for the result.</param>
            <param name="considerUnspecifiedAsUtc">If true then values with no timezone are considered to be UTC.</param>
            <returns>Equivalent .net <see cref="T:System.DateTime"/> object.</returns>
            <remarks>
            If <c>considerUnspecifiedAsUtc</c> is false, then converting to a <see cref="F:System.DateTimeKind.Local"/> <see cref="T:System.DateTime"/>
            will not apply any offset calculation, but simply use the time as it is.
            </remarks>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToDateTimeOffset">
            <summary>
            Converts this <c>FudgeDateTime</c> to a .net <see cref="T:System.DateTimeOffset"/> object.
            </summary>
            <returns>Equivalent <see cref="T:System.DateTimeOffset"/>.</returns>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.GetTypeCode">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToBoolean(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToByte(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToChar(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToDateTime(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToDecimal(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToDouble(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToInt16(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToInt32(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToInt64(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToSByte(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToSingle(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToType(System.Type,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToUInt16(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToUInt32(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeDateTime.ToUInt64(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Year">
            <summary>
            Gets the year part of the <c>FudgeDateTime</c>.
            </summary>
            <remarks>
            Note that 1 AD is year 1, and 1 BC is year -1.  Year 0 is meaningless.
            </remarks>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Month">
            <summary>
            Gets the month part of the <c>FudgeDateTime</c>, in the range 1 to 12 for valid dates.
            </summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Day">
            <summary>
            Gets the day part of the <c>FudgeDateTime</c>, in the range 1 to 31 for valid dates.
            </summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.IsValidDate">
            <summary>
            Indicates whether the <c>FudgeDateTime</c> represents a real date
            </summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Hour">
            <summary>Gets the hour component of this <c>FudgeDateTime</c>.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Minute">
            <summary>Gets the minute component of this <c>FudgeDateTime</c>.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Second">
            <summary>Gets the seconds component of this <c>FudgeDateTime</c>.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Nanoseconds">
            <summary>Gets the nanoseconds component of this <c>FudgeDateTime</c>.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.TimeZoneOffset">
            <summary>Gets the offset from UTC in minutes.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Date">
            <summary>Gets the date component of this <c>FudgeDateTime</c>.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Time">
            <summary>Gets the time component of this <c>FudgeDateTime</c>.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeDateTime.Precision">
            <summary>Gets the precision of this <c>FudgeDateTime</c>.</summary>
        </member>
        <member name="T:Fudge.Types.FudgeDateTimePrecision">
            <summary>
            <c>FudgeDateTimePrecision</c> expresses the resolution of a <see cref="T:Fudge.Types.FudgeDateTime"/> or <see cref="T:Fudge.Types.FudgeTime"/> object.
            </summary>
            <remarks>
            The values are as defined in the specification at http://www.fudgemsg.org/display/FDG/DateTime+encoding
            </remarks>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Millennium">
            <summary>The object is accurate to the nearest millennium.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Century">
            <summary>The object is accurate to the nearest century.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Year">
            <summary>The object is accurate to the nearest year.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Month">
            <summary>The object is accurate to the nearest month.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Day">
            <summary>The object is accurate to the nearest day.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Hour">
            <summary>The object is accurate to the nearest hour.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Minute">
            <summary>The object is accurate to the nearest minute.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Second">
            <summary>The object is accurate to the nearest second.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Millisecond">
            <summary>The object is accurate to the nearest millisecond.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Microsecond">
            <summary>The object is accurate to the nearest microsecond.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeDateTimePrecision.Nanosecond">
            <summary>The object is accurate to the nearest nanosecond.</summary>
        </member>
        <member name="T:Fudge.Types.FudgeTime">
            <summary>
            <c>FudgeTime</c> represents a pure time value (i.e. one with no date component), with up to nanosecond resolution, and
            optionally carrying timezone information.
            </summary>
        </member>
        <member name="F:Fudge.Types.FudgeTime.DefaultDateTimePrecision">
            <summary>The default precision assumed for .net <see cref="T:System.DateTime"/> objects.</summary>
        </member>
        <member name="F:Fudge.Types.FudgeTime.Midnight">
            <summary>Represents midnight with no timezone</summary>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(System.Int32)">
            <summary>
            Constructs a new <c>FudgeTime</c> which is just hours, without a timezone.
            </summary>
            <param name="hour"></param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new <c>FudgeTime</c> based on separate hours and minutes, without a timezone.
            </summary>
            <param name="hour"></param>
            <param name="minute"></param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a new <c>FudgeTime</c> based on separate hours, minutes, seconds without a timezone.
            </summary>
            <param name="hour"></param>
            <param name="minute"></param>
            <param name="second"></param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a new <c>FudgeTime</c> based on separate hours, minutes and seconds, with a timezone.
            </summary>
            <param name="hour"></param>
            <param name="minute"></param>
            <param name="second"></param>
            <param name="timeZoneOffset">Timezone offset from UTC, in minutes, must be multiple of 15</param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Constructs a new <c>FudgeTime</c> based on separate hours, minutes, seconds and nanoseconds, without a timezone.
            </summary>
            <param name="hour"></param>
            <param name="minute"></param>
            <param name="second"></param>
            <param name="nanoseconds"></param>
            <param name="precision"></param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Nullable{System.Int32},Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Constructs a new <c>FudgeTime</c> based on separate hours, minutes, seconds and nanoseconds, with a timezone.
            </summary>
            <param name="hour"></param>
            <param name="minute"></param>
            <param name="second"></param>
            <param name="nanoseconds"></param>
            <param name="timeZoneOffset">Timezone offset from UTC, in minutes, must be multiple of 15</param>
            <param name="precision"></param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(Fudge.Types.FudgeDateTimePrecision,System.Int32,System.Int32)">
            <summary>
            Constructs a new <c>FudgeTime</c> based on a total number of seconds and nanoseconds, without a timezone.
            </summary>
            <param name="precision"></param>
            <param name="totalSeconds"></param>
            <param name="nanoseconds"></param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(Fudge.Types.FudgeDateTimePrecision,System.Int32,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Constructs a new <c>FudgeTime</c> based on a total number of seconds and nanoseconds, with a timezone.
            </summary>
            <param name="precision"></param>
            <param name="totalSeconds"></param>
            <param name="nanoseconds"></param>
            <param name="timeZoneOffset">Timezone offset from UTC, in minutes, must be multiple of 15</param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(System.DateTime)">
            <summary>
            Constructs a <c>FudgeTime</c> from the time components of a .net <see cref="T:System.DateTime"/>.
            </summary>
            <param name="dateTime"><see cref="T:System.DateTime"/> to use.</param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.#ctor(System.DateTime,Fudge.Types.FudgeDateTimePrecision)">
            <summary>
            Constructs a <c>FudgeTime</c> from the time components of a .net <see cref="T:System.DateTime"/>, specifying the precision.
            </summary>
            <param name="dateTime"><see cref="T:System.DateTime"/> to use.</param>
            <param name="precision"><see cref="T:Fudge.Types.FudgeDateTimePrecision"/> for this <c>FudgeTime</c>.</param>
        </member>
        <member name="M:Fudge.Types.FudgeTime.ToString">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeTime.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeTime.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="P:Fudge.Types.FudgeTime.Hour">
            <summary>Gets the hour component of this time.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeTime.Minute">
            <summary>Gets the minute component of this time.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeTime.Second">
            <summary>Gets the seconds component of this time.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeTime.TotalSeconds">
            <summary>Gets the total number of whole seconds since midnight that this time represents.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeTime.Nanoseconds">
            <summary>Gets the nanoseconds component of this time.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeTime.TotalNanoseconds">
            <summary>Gets the total number of nanoseconds since midnight that this time represents.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeTime.TimeZoneOffset">
            <summary>Gets the offset from UTC in minutes, or returns <c>null</c> if there is no timezone.</summary>
        </member>
        <member name="P:Fudge.Types.FudgeTime.Precision">
            <summary>Gets the precision of this time, as a <see cref="T:Fudge.Types.FudgeDateTimePrecision"/>.</summary>
        </member>
        <member name="T:Fudge.ISecondaryFieldType">
            <summary>
            Marker interface to indicate that this type isn't a primary type
            </summary>
        </member>
        <member name="T:Fudge.SecondaryFieldType`2">
            <summary>
            SecondaryFieldTypes are used to represent <see cref="T:Fudge.FudgeFieldType"/>s that are represented as
            a more primitive type when encoded.
            </summary>
            <typeparam name="T">Value type for this field.</typeparam>
            <typeparam name="RawType">Type for the more primitive encoded value.</typeparam>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.#ctor(Fudge.FudgeFieldType,System.Converter{`1,`0},System.Converter{`0,`1})">
            <summary>
            Cosntructs a new <c>SeondaryFieldType</c>.
            </summary>
            <param name="wireType">Canonical type that values of this type will be represented as when encoded.</param>
            <param name="inputConverter">Function to convert values from canonical type to this type.</param>
            <param name="outputConverter">Function to convert values from this type to the canonical type.</param>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.#ctor(Fudge.FudgeFieldType)">
            <summary>
            Cosntructs a new <c>SeondaryFieldType</c> without conversion functions.
            </summary>
            <param name="wireType">Canonical type that values of this type will be represented as when encoded.</param>
            <remarks>
            Derived types can use this form if they wish to override <see cref="M:Fudge.SecondaryFieldType`2.Minimize(System.Object,Fudge.FudgeFieldType@)"/> and <see cref="M:Fudge.SecondaryFieldType`2.ConvertValueFrom(System.Object)"/>
            directly rather than supplying conversion functions.
            </remarks>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.GetVariableSize(`0,Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc cref="M:Fudge.FudgeFieldType.GetVariableSize(System.Object,Fudge.Taxon.IFudgeTaxonomy)"/>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.WriteValue(System.IO.BinaryWriter,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.Minimize(System.Object,Fudge.FudgeFieldType@)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.ConvertValueFrom(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.ConvertToWire(`0)">
            <summary>
            Override ConvertToWire if you do not wish to use a delegate.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fudge.SecondaryFieldType`2.ConvertFromWire(`1)">
            <summary>
            Override ConvertFromWire if you do not wish to use a delegate.
            </summary>
            <param name="rawValue"></param>
            <returns></returns>
        </member>
        <member name="T:Fudge.Taxon.IFudgeTaxonomy">
            <summary>
            A Fudge Taxonomy is a mapping from ordinals to names for
            fields in a Fudge Encoded data format
            </summary>
        </member>
        <member name="M:Fudge.Taxon.IFudgeTaxonomy.GetFieldName(System.Int16)">
            <summary>
            Obtain the field name appropriate for a field with the
            specified ordinal within this taxonomy.
            </summary>
            <param name="ordinal">The ordinal to locate a field name.</param>
            <returns>he field name, or <c>null</c> if no name available for
            a field with the specified ordinal in this taxonomy.</returns>
        </member>
        <member name="M:Fudge.Taxon.IFudgeTaxonomy.GetFieldOrdinal(System.String)">
            <summary>
            Obtain the field ordinal appropriate for a field with the
            specified name within this taxonomy.
            </summary>
            <param name="fieldName">The name to locate an ordinal for.</param>
            <returns>The field ordinal, or <c>null</c> if no ordinal available
            for a field with the specified name in this taxonomy.</returns>
        </member>
        <member name="T:Fudge.Taxon.ITaxonomyResolver">
            <summary>
            A Taxonomy Resolver can identify a <see cref="T:Fudge.Taxon.IFudgeTaxonomy"/> instance that is
            appropriate for a message with a specific taxonomy ID.
            This ID is actually appropriate for a particular application, and possibly
            for a particular point in time. In fact, it may be appropriate for a particular
            stream of data from a particular source, and some applications may have
            multiple <c>ITaxonomyResolver</c>s loaded into a single application. 
            </summary>
            <seealso cref="T:Fudge.Taxon.TaxonomyResolver"/>
        </member>
        <member name="M:Fudge.Taxon.ITaxonomyResolver.ResolveTaxonomy(System.Int16)">
            <summary>
            Identify the taxonomy that should be used to resolve names with the
            specified ID.
            </summary>
            <param name="taxonomyId">The ID of the taxonomy to load</param>
            <returns>The taxonomy, or <c>null</c></returns>
        </member>
        <member name="T:Fudge.Taxon.TaxonomyResolver">
            <summary>
            Delegate form for Taxonomy Resolver for when you don't need to create an object
            </summary>
            <seealso cref="T:Fudge.Taxon.ITaxonomyResolver"/>
            <param name="taxonomyId">The ID of the taxonomy to load</param>
            <returns>The taxonomy, or <c>null</c></returns>
        </member>
        <member name="T:Fudge.Taxon.ImmutableMapTaxonomyResolver">
            <summary>
            An implementation of <see cref="T:Fudge.Taxon.TaxonomyResolver"/> which is backed by a Dictionary.
            This is mostly useful where the entire set of taxonomies is known at module
            initialization (or compilation) time. As for performance reasons the
            <see cref="T:System.Collections.Generic.Dictionary`2"/> is fixed at instantiation time, it is not appropriate for
            situations where the set of taxonomies will change at runtime.
            </summary>
        </member>
        <member name="M:Fudge.Taxon.ImmutableMapTaxonomyResolver.#ctor">
            <summary>
            The default constructor will result in a resolver that never
            resolves any taxonomies.
            </summary>
        </member>
        <member name="M:Fudge.Taxon.ImmutableMapTaxonomyResolver.#ctor(System.Collections.Generic.Dictionary{System.Int32,Fudge.Taxon.IFudgeTaxonomy})">
            <summary>
            Creates a new resolver with the given map of taxonomy IDs to taxonomy instances.
            </summary>
            <param name="taxonomiesById">taxonomy resolution map</param>
        </member>
        <member name="M:Fudge.Taxon.ImmutableMapTaxonomyResolver.ResolveTaxonomy(System.Int16)">
            <inheritdoc />
        </member>
        <member name="T:Fudge.Taxon.MapFudgeTaxonomy">
            <summary>
            An implementation of <see cref="T:Fudge.Taxon.IFudgeTaxonomy"/> where all lookups are specified
            at construction time and held in a <see cref="T:System.Collections.Generic.Dictionary`2"/>.
            This is extremely useful in a case where the taxonomy is generated dynamically,
            or as a building block for loading taxonomy definitions from persistent
            storage.
            </summary>
        </member>
        <member name="M:Fudge.Taxon.MapFudgeTaxonomy.#ctor">
            <summary>
            Creates a new taxonomy with an empty dictionary.
            </summary>
        </member>
        <member name="M:Fudge.Taxon.MapFudgeTaxonomy.#ctor(System.Collections.Generic.Dictionary{System.Int32,System.String})">
            <summary>
            Creates a new taxonomy with a default dictionary to map field names to/from ordinal values.
            </summary>
            <param name="namesByOrdinal">initial mapping of ordinals to field names</param>
        </member>
        <member name="M:Fudge.Taxon.MapFudgeTaxonomy.#ctor(System.Int32[],System.String[])">
            <summary>
            Creates a new taxonomy from a set of ordinals and the corresponding set of field names. The arrays must be of equal length.
            </summary>
            <param name="ordinals">array of ordinal values</param>
            <param name="names">array of field names</param>
        </member>
        <member name="M:Fudge.Taxon.MapFudgeTaxonomy.GetFieldName(System.Int16)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Taxon.MapFudgeTaxonomy.GetFieldOrdinal(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Fudge.Types.ByteArrayFieldType">
            <summary>
            The type definition for a byte array. The Fudge encoding specification allows arrays of bytes to be handled as arbitrary
            lengths, or as one of a set of predefined fixed-width types for common sizes.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.VariableSizedInstance">
            <summary>
            A type defintion for an arbitrary length byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length4Instance">
            <summary>
            A type definition for a 4 byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length8Instance">
            <summary>
            A type definition for an 8 byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length16Instance">
            <summary>
            A type definition for a 16 byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length20Instance">
            <summary>
            A type definition for a 20 byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length32Instance">
            <summary>
            A type definition for a 32 byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length64Instance">
            <summary>
            A type definition for a 64 byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length128Instance">
            <summary>
            A type definition for a 128 byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length256Instance">
            <summary>
            A type definition for a 256 byte array.
            </summary>
        </member>
        <member name="F:Fudge.Types.ByteArrayFieldType.Length512Instance">
            <summary>
            A type definition for a 512 byte array.
            </summary>
        </member>
        <member name="M:Fudge.Types.ByteArrayFieldType.#ctor">
            <summary>
            Creates a new type definition for arbitrary length byte arrays.
            </summary>
        </member>
        <member name="M:Fudge.Types.ByteArrayFieldType.#ctor(System.Byte,System.Int32)">
            <summary>
            Creates a new type definition for a fixed length byte array. The default Fudge types have optimised typese for common lengths
            that produces a more compact encoding.
            </summary>
            <param name="typeId">type ID</param>
            <param name="length">fixed length of array</param>
        </member>
        <member name="M:Fudge.Types.ByteArrayFieldType.GetVariableSize(System.Byte[],Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Types.ByteArrayFieldType.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Types.ByteArrayFieldType.WriteValue(System.IO.BinaryWriter,System.Byte[])">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Types.ByteArrayFieldType.Minimize(System.Object,Fudge.FudgeFieldType@)">
            <summary>
            Attempts to reduce a variable length byte array to one of the standard Fudge types. The value
            is never modified, just the type changed.
            </summary>
            <param name="value">value to process</param>
            <param name="type">type definition</param>
            <returns>the value</returns>
        </member>
        <member name="M:Fudge.Types.ByteArrayFieldType.ConvertValueFrom(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:Fudge.Types.LongArrayFieldType">
            <summary>
            The type definition for an array of 64-bit integers.
            </summary>
        </member>
        <member name="F:Fudge.Types.LongArrayFieldType.Instance">
            <summary>
            A type definition for arrays of signed 64-bit integers.
            </summary>
        </member>
        <member name="M:Fudge.Types.LongArrayFieldType.#ctor">
            <summary>
            Creates a type definition for arrays of signed 64-bit integers.
            </summary>
        </member>
        <member name="T:Fudge.Types.ShortArrayFieldType">
            <summary>
            The type definition for an array of 16-bit integers.
            </summary>
        </member>
        <member name="F:Fudge.Types.ShortArrayFieldType.Instance">
            <summary>
            A type definition for arrays of signed 16-bit integers.
            </summary>
        </member>
        <member name="M:Fudge.Types.ShortArrayFieldType.#ctor">
            <summary>
            Creates a type definition for arrays of signed 16-bit integers.
            </summary>
        </member>
        <member name="T:Fudge.Types.IntArrayFieldType">
            <summary>
            The type definition for an array of 32-bit integers.
            </summary>
        </member>
        <member name="F:Fudge.Types.IntArrayFieldType.Instance">
            <summary>
            A type defintion for an array of 32-bit integers.
            </summary>
        </member>
        <member name="M:Fudge.Types.IntArrayFieldType.#ctor">
            <summary>
            Creates a new type definition for an array of 32-bit integers.
            </summary>
        </member>
        <member name="T:Fudge.Types.DoubleArrayFieldType">
            <summary>
            The type definition for an array of double-precision floating point numbers.
            </summary>
        </member>
        <member name="F:Fudge.Types.DoubleArrayFieldType.Instance">
            <summary>
            A type definition for an array of double-precision floating point numbers.
            </summary>
        </member>
        <member name="M:Fudge.Types.DoubleArrayFieldType.#ctor">
            <summary>
            Creates a new type definition for an array of double-precision floating point numbers.
            </summary>
        </member>
        <member name="T:Fudge.Types.FloatArrayFieldType">
            <summary>
            The type definition for an array of single-precision floating point numbers.
            </summary>
        </member>
        <member name="F:Fudge.Types.FloatArrayFieldType.Instance">
            <summary>
            A type definition for arrays of single precision (32-bit) floating point values.
            </summary>
        </member>
        <member name="M:Fudge.Types.FloatArrayFieldType.#ctor">
            <summary>
            Creates a new type definition for arrays of single precision (32-bit) floating point values.
            </summary>
        </member>
        <member name="T:Fudge.Types.FudgeMsgFieldType">
            <summary>
            The type definition for a sub-message in a hierarchical message format.
            </summary>
        </member>
        <member name="F:Fudge.Types.FudgeMsgFieldType.Instance">
            <summary>
            A type definition for values that are sub-messages.
            </summary>
        </member>
        <member name="M:Fudge.Types.FudgeMsgFieldType.GetVariableSize(Fudge.FudgeMsg,Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc cref="M:Fudge.FudgeFieldType.GetVariableSize(System.Object,Fudge.Taxon.IFudgeTaxonomy)"/>
        </member>
        <member name="M:Fudge.Types.FudgeMsgFieldType.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.FudgeMsgFieldType.WriteValue(System.IO.BinaryWriter,Fudge.FudgeMsg)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Types.IndicatorFieldType">
            <summary>
            The type definition for an indicator type - a field type which carries no data.
            </summary>
        </member>
        <member name="F:Fudge.Types.IndicatorFieldType.Instance">
            <summary>
            A type definition for the indicator type.
            </summary>
        </member>
        <member name="M:Fudge.Types.IndicatorFieldType.#ctor">
            <summary>
            Creates a new type definition for the indicator type.
            </summary>
        </member>
        <member name="M:Fudge.Types.IndicatorFieldType.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.IndicatorFieldType.WriteValue(System.IO.BinaryWriter,Fudge.Types.IndicatorType)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Types.IndicatorType">
            <summary>
            The only value of a field with the Indicator type.
            </summary>
        </member>
        <member name="F:Fudge.Types.IndicatorType.Instance">
            <summary>
            The only instance of this type.
            </summary>
        </member>
        <member name="M:Fudge.Types.IndicatorType.GetTypeCode">
            <inheritdoc cref="M:System.IConvertible.GetTypeCode"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToBoolean(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToByte(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToByte(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToChar(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToChar(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToDateTime(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToDecimal(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToDouble(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToDouble(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToInt16(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToInt16(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToInt32(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToInt32(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToInt64(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToInt64(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToSByte(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToSByte(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToSingle(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToSingle(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToString(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToString(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToType(System.Type,System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToUInt16(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToUInt32(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)"/>
        </member>
        <member name="M:Fudge.Types.IndicatorType.ToUInt64(System.IFormatProvider)">
            <inheritdoc cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)"/>
        </member>
        <member name="T:Fudge.Types.PrimitiveFieldTypes">
            <summary>
             A collection of all the simple fixed-width field types that represent
             primitive values.
             Because these are fast-pathed inside the encoder/decoder sequence,
             there's no point in breaking them out to other classes.
            </summary>
        </member>
        <member name="F:Fudge.Types.PrimitiveFieldTypes.BooleanType">
            <summary>
            A type definition for boolean values.
            </summary>
        </member>
        <member name="F:Fudge.Types.PrimitiveFieldTypes.SByteType">
            <summary>
            A type definition for 8-bit byte values.
            </summary>
        </member>
        <member name="F:Fudge.Types.PrimitiveFieldTypes.ShortType">
            <summary>
            A type definition for signed 16-bit integers.
            </summary>
        </member>
        <member name="F:Fudge.Types.PrimitiveFieldTypes.IntType">
            <summary>
            A type definition for signed 32-bit integers.
            </summary>
        </member>
        <member name="F:Fudge.Types.PrimitiveFieldTypes.LongType">
            <summary>
            A type definition for signed 64-bit integers.
            </summary>
        </member>
        <member name="F:Fudge.Types.PrimitiveFieldTypes.FloatType">
            <summary>
            A type definition for single precision (32-bit) floating point values.
            </summary>
        </member>
        <member name="F:Fudge.Types.PrimitiveFieldTypes.DoubleType">
            <summary>
            A type definition for double precision (64-bit) floating point values.
            </summary>
        </member>
        <member name="M:Fudge.Types.PrimitiveFieldTypes.MinimizeIntegers(System.Int64,Fudge.FudgeFieldType@)">
            <summary>
            Delegate for reducing integers to the smallest encoding available.
            </summary>
            <param name="valueAsLong">value to reduce</param>
            <param name="type">original type</param>
            <returns>the original value, recast to a smaller type if reduction has taken place</returns>
        </member>
        <member name="T:Fudge.Types.StringFieldType">
            <summary>
            The type definition for a UTF-8 encoded string.
            </summary>
        </member>
        <member name="F:Fudge.Types.StringFieldType.Instance">
            <summary>
            A type defintion for string data.
            </summary>
        </member>
        <member name="M:Fudge.Types.StringFieldType.#ctor">
            <summary>
            Creates a type definition for string data.
            </summary>
        </member>
        <member name="M:Fudge.Types.StringFieldType.GetVariableSize(System.String,Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc cref="M:Fudge.FudgeFieldType.GetVariableSize(System.Object,Fudge.Taxon.IFudgeTaxonomy)"/>
        </member>
        <member name="M:Fudge.Types.StringFieldType.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.StringFieldType.WriteValue(System.IO.BinaryWriter,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Types.TimeFieldType">
            <summary>
            The type definition for a Fudge-encoded time
            </summary>
        </member>
        <member name="F:Fudge.Types.TimeFieldType.Instance">
            <summary>
            A type defintion for time data.
            </summary>
        </member>
        <member name="M:Fudge.Types.TimeFieldType.#ctor">
            <summary>
            Creates a new time field type
            </summary>
        </member>
        <member name="M:Fudge.Types.TimeFieldType.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.TimeFieldType.WriteValue(System.IO.BinaryWriter,Fudge.Types.FudgeTime)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.Types.UnknownFudgeFieldType">
            <summary>
            A type class for handling variable sized field values where the type
            isn't available in the current <see cref="T:Fudge.FudgeTypeDictionary"/>.
            </summary>
        </member>
        <member name="M:Fudge.Types.UnknownFudgeFieldType.#ctor(System.Int32)">
            <summary>
            Creates a new placeholder for a type ID not available in the current dictionary.
            </summary>
            <param name="typeId"></param>
        </member>
        <member name="M:Fudge.Types.UnknownFudgeFieldType.GetVariableSize(Fudge.UnknownFudgeFieldValue,Fudge.Taxon.IFudgeTaxonomy)">
            <inheritdoc cref="M:Fudge.FudgeFieldType.GetVariableSize(System.Object,Fudge.Taxon.IFudgeTaxonomy)"/>
        </member>
        <member name="M:Fudge.Types.UnknownFudgeFieldType.ReadTypedValue(System.IO.BinaryReader,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Fudge.Types.UnknownFudgeFieldType.WriteValue(System.IO.BinaryWriter,Fudge.UnknownFudgeFieldValue)">
            <inheritdoc/>
        </member>
        <member name="T:Fudge.UnknownFudgeFieldValue">
            <summary>
            Container for a variable-sized field with a type that the current
            installation of Fudge cannot handle on decoding.
            In general, while Fudge supports an infinite number of
            <see cref="T:Fudge.Types.UnknownFudgeFieldType"/> instances with a particular type ID, it
            is optimal to use the factory method <see cref="M:Fudge.FudgeTypeDictionary.GetUnknownType(System.Int32)"/>
            to obtain one for a particular context, which is what the Fudge decoding
            routines will do. 
            </summary>
        </member>
        <member name="M:Fudge.UnknownFudgeFieldValue.#ctor(System.Byte[],Fudge.Types.UnknownFudgeFieldType)">
            <summary>
            Creates a new unknown value.
            </summary>
            <param name="contents">the binary data from the fudge message</param>
            <param name="type">the unknown type placeholder</param>
        </member>
        <member name="P:Fudge.UnknownFudgeFieldValue.Contents">
            <summary>
            Gets the binary data value
            </summary>
        </member>
        <member name="P:Fudge.UnknownFudgeFieldValue.Type">
            <summary>
            Gets the unknown type definition
            </summary>
        </member>
        <member name="T:Fudge.Util.BinaryNBOReader">
            <summary>
            Like the <see cref="T:System.IO.BinaryReader"/>, but uses Network Byte Order for compatiblility with other languages.
            </summary>
            <remarks>Note that only the integer types plus float and double have been overridden.</remarks>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a new stream reader with the default UTF8 encoding.
            </summary>
            <param name="input">underlying input stream</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Creates a new stream reader with a custom encoding.
            </summary>
            <param name="input">underlying input stream</param>
            <param name="encoding">custom encoding</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.ReadInt16">
            <summary>
            Reads a signed 16-bit integer in network byte order.
            </summary>
            <returns>value read</returns>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.ReadUInt16">
            <summary>
            Reads an unsigned 16-bit integer in network byte order.
            </summary>
            <returns>value read</returns>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.ReadInt32">
            <summary>
            Reads a signed 32-bit integer in network byte order.
            </summary>
            <returns>value read</returns>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.ReadUInt32">
            <summary>
            Reads an unsigned 32-bit integer in network byte order.
            </summary>
            <returns>value read</returns>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.ReadInt64">
            <summary>
            Reads a signed 64-bit integer in network byte order.
            </summary>
            <returns>value read</returns>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.ReadUInt64">
            <summary>
            Reads an unsigned 64-bit integer in network byte order.
            </summary>
            <returns>value read</returns>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.ReadSingle">
            <summary>
            Reads a 32-bit (single precision) floating point value in network byte order.
            </summary>
            <returns>value read</returns>
        </member>
        <member name="M:Fudge.Util.BinaryNBOReader.ReadDouble">
            <summary>
            Reads a 64-bit (double precision) floating point value in network byte order.
            </summary>
            <returns>value read</returns>
        </member>
        <member name="T:Fudge.Util.BinaryNBOWriter">
            <summary>
            Like the <see cref="T:System.IO.BinaryWriter"/>, but uses Network Byte Order for compatiblility with other languages.
            </summary>
            <remarks>Note that only the integer types plus float and double have been overridden.</remarks>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.#ctor(System.IO.Stream)">
            <summary>
            Creates a new stream writer.
            </summary>
            <param name="output">underlying target stream</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.#ctor(System.IO.Stream,System.Text.Encoding)">
            <summary>
            Creates a new stream writer
            </summary>
            <param name="output">underlying target stream</param>
            <param name="encoding">custom encoding</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.Write(System.Int16)">
            <summary>
            Writes a signed 16-bit integer in network byte order.
            </summary>
            <param name="value">value to write</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.Write(System.UInt16)">
            <summary>
            Writes an unsigned 16-bit integer in network byte order.
            </summary>
            <param name="value">value to write</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.Write(System.Int32)">
            <summary>
            Writes a signed 32-bit integer in network byte order.
            </summary>
            <param name="value">value to write</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.Write(System.UInt32)">
            <summary>
            Writes an unsigned 32-bit integer in network byte order.
            </summary>
            <param name="value">value to write</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.Write(System.Int64)">
            <summary>
            Writes a signed 64-bit integer in network byte order
            </summary>
            <param name="value">value to write</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.Write(System.UInt64)">
            <summary>
            Writes an unsigned 64-bit integer in network byte order.
            </summary>
            <param name="value">value to write</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.Write(System.Single)">
            <summary>
            Writes a single precision (32-bit) floating point number in network byte order.
            </summary>
            <param name="value">value to write</param>
        </member>
        <member name="M:Fudge.Util.BinaryNBOWriter.Write(System.Double)">
            <summary>
            Writes a double precision (64-bit) floating point number in network byte order.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Fudge.Util.FudgeBinaryReader">
            <summary>
            FudgeBinaryReader provides the wire encoding for primitive types.
            </summary>
            <remarks>
            The default <see cref="T:System.IO.BinaryReader"/> uses little-endian integer encoding, and UTF8, whereas Fudge always
            uses Network Byte Order (i.e. big-endian) and UTF-8 (note that before version 0.3 it was using modified UTF-8.
            </remarks>
        </member>
        <member name="M:Fudge.Util.FudgeBinaryReader.#ctor(System.IO.Stream)">
            <summary>
            Cosntructs a new <c>FudgeBinaryReader</c> on an input <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="input">Stream to read binary data from.</param>
        </member>
        <member name="T:Fudge.Util.FudgeBinaryWriter">
            <summary>
            FudgeBinaryWriter provides the wire encoding for primitive types.
            </summary>
            <remarks>
            The default <see cref="T:System.IO.BinaryWriter"/> uses little-endian integer encoding, and UTF8, whereas Fudge always
            uses Network Byte Order (i.e. big-endian) and UTF-8 (note that before version 0.3 it was using modified UTF-8.
            </remarks>
        </member>
        <member name="M:Fudge.Util.FudgeBinaryWriter.#ctor(System.IO.Stream)">
            <summary>
            Cosntructs a new <c>FudgeBinaryWriter</c> on an output <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="output">Stream to write binary data to.</param>
        </member>
        <member name="T:Fudge.Util.ModifiedUTF8Encoding">
            <summary>
            Encoding to support working with <a href="http://en.wikipedia.org/wiki/UTF-8#Modified_UTF-8">Modified UTF-8</a> data.
            </summary>
        </member>
        <member name="M:Fudge.Util.ModifiedUTF8Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Util.ModifiedUTF8Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Util.ModifiedUTF8Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Util.ModifiedUTF8Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Util.ModifiedUTF8Encoding.GetMaxByteCount(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Fudge.Util.ModifiedUTF8Encoding.GetMaxCharCount(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Fudge.Util.ModifiedUTF8Encoding.UTFDataFormatException">
            <summary>
            <c>UTFDataFormatException</c> is thrown when there is a problem encoding or decoding modified-UTF8 data.
            </summary>
        </member>
        <member name="M:Fudge.Util.ModifiedUTF8Encoding.UTFDataFormatException.#ctor(System.String)">
            <summary>
            Constructs a new <c>UTFDataFormatException</c>
            </summary>
            <param name="message"></param>
        </member>
    </members>
</doc>
